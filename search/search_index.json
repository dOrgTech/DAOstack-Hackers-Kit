{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAOstack DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"Home"},{"location":"#daostack","text":"DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"DAOstack"},{"location":"arc2-overview/","text":"Arc 2.0 What's new on the latest version of DAOstack architecture? Overview Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility. The changes None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"Arc 2.0"},{"location":"arc2-overview/#arc-20","text":"What's new on the latest version of DAOstack architecture?","title":"Arc 2.0"},{"location":"arc2-overview/#overview","text":"Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility.","title":"Overview"},{"location":"arc2-overview/#the-changes","text":"None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"The changes"},{"location":"plugins/funding-request/","text":"","title":"Funding Request"},{"location":"plugins/nft-manager/","text":"","title":"NFT Manager"},{"location":"plugins/token-trade/","text":"","title":"Token Trade"},{"location":"stack/alchemy/","text":"","title":"Alchemy"},{"location":"stack/arc/","text":"Arc Arc is a solidity smart contract library for building DAOs, uses Infra to provide decentralized organizations with voting machines and voting rights management systems. Is the base layer of the DAO stack. It defines the basic building blocks and standard components that can be used to implement any DAO. DAOs built with Arc have a few basic contract components: Avatar : The DAO's \"account\". This contract represents the address of the DAO and holds its assets. Reputation : Voting in Arc is done mainly using Reputation. Reputation can be distributed and redistributed only by DAO decision, and it is generally given (via vote) to an agent according to their performance and contribution to a DAO. Token : Each DAO have its own token, which can be used in any way the DAO would like. Controller : Is the \"Access Control\" of the DAO, managing who can interact with which DAO functions and enforcing the DAO's constraints. Plugins : Are a DAO's \"actions\". Anything a DAO should act upon needs to be written and authorized by the controller as a plugin. Plugins might be used to help a DAO: propose and make investments, give reputation to agents, upgrade the DAO's contracts, register new plugins and constraints, etc. Global Constraints : Are limitations on a DAO's actions. When executing a plugin, the controller checks the constraints to see if the action violates them, and blocks the execution if it does. Some examples for constraints might be: the token supply can't be increased over 1M tokens, the organization won't use more than 60% of its funds at once, etc. It has been built from the ground up with these principles in mind: Scalable Decentralized Governance - Implements game theory & economic techniques (such as: monetization of attention, staking on proposal results, and more) that, even as the number of the participants gets very large, ensures high: Resilience - resistance to a disproportionate decision power in the hands of minorities. Bandwidth - decision making rate of the organization. Security - Is community audited and embodies the best security guidelines and is very well tested. Interoperability & Compositionality - Can integrate with any other ethereum based framework with ease. Organizations can interact with each other and form hierarchies and other complex structures. Modularity - Is built in a modular way allowing anyone to extend and expand the ecosystem to support new use-cases. General purpose - Provides a single unified simple model for building any DAO imaginable.","title":"Arc"},{"location":"stack/arc/#arc","text":"Arc is a solidity smart contract library for building DAOs, uses Infra to provide decentralized organizations with voting machines and voting rights management systems. Is the base layer of the DAO stack. It defines the basic building blocks and standard components that can be used to implement any DAO. DAOs built with Arc have a few basic contract components: Avatar : The DAO's \"account\". This contract represents the address of the DAO and holds its assets. Reputation : Voting in Arc is done mainly using Reputation. Reputation can be distributed and redistributed only by DAO decision, and it is generally given (via vote) to an agent according to their performance and contribution to a DAO. Token : Each DAO have its own token, which can be used in any way the DAO would like. Controller : Is the \"Access Control\" of the DAO, managing who can interact with which DAO functions and enforcing the DAO's constraints. Plugins : Are a DAO's \"actions\". Anything a DAO should act upon needs to be written and authorized by the controller as a plugin. Plugins might be used to help a DAO: propose and make investments, give reputation to agents, upgrade the DAO's contracts, register new plugins and constraints, etc. Global Constraints : Are limitations on a DAO's actions. When executing a plugin, the controller checks the constraints to see if the action violates them, and blocks the execution if it does. Some examples for constraints might be: the token supply can't be increased over 1M tokens, the organization won't use more than 60% of its funds at once, etc. It has been built from the ground up with these principles in mind: Scalable Decentralized Governance - Implements game theory & economic techniques (such as: monetization of attention, staking on proposal results, and more) that, even as the number of the participants gets very large, ensures high: Resilience - resistance to a disproportionate decision power in the hands of minorities. Bandwidth - decision making rate of the organization. Security - Is community audited and embodies the best security guidelines and is very well tested. Interoperability & Compositionality - Can integrate with any other ethereum based framework with ease. Organizations can interact with each other and form hierarchies and other complex structures. Modularity - Is built in a modular way allowing anyone to extend and expand the ecosystem to support new use-cases. General purpose - Provides a single unified simple model for building any DAO imaginable.","title":"Arc"},{"location":"stack/arcjs/development/","text":"Developing For development, it is useful to have local instances of Ganache (an ethereum node), IPFS (which is used to store data), an instance of The Graph with the DAOStack subgraph. The package is provided with convenient docker containers that provide a complete environment for testing and development: Get all services running: docker-compose up This command will build and start a graph instance, ganache, IPFS and postgresql. To run the tests, run: npm run test You may also want to run the (demo.js)[./documentation/demo.js] file for some concrete examples of the usage of the library: node documentation/demo.js After you are done, run: docker-compose down Adding an Entity The Event entity will be used as example in this section. To add an entity to the library, you must: Create an interface that defines the entity state. export interface IEventState { id: string dao: string proposal: string user: string type: string data: { [key: string]: any } timestamp: string } Create an interface that defines the possible options to query the entity. This interface must extend the ICommonQueryOptions interface. export interface IEventQueryOptions extends ICommonQueryOptions { where?: { id?: string; dao?: Address; proposal?: string; user?: Address; [key: string]: any; } } Create the entity class. This class must extend the Entity<TState> abstract class, where TState is the interface created in step 1. Implement the public static fragments field. Here you can define entity related GraphQL fragments to use in GraphQL queries. public static fragments = { EventFields: gql` fragment EventFields on Event { id dao { id } type data user proposal { id } timestamp } ` } Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): IEntityState The goal of this method is to map the item object received by a query to an object of its interface. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. public static itemMap(context: Arc, item: any, queriedId?: string): IEventState { if (!item) { throw Error(`Event ItemMap failed. ${queriedId ? `Could not find Event with id '${queriedId}'` : ''}`) } return { dao: item.dao.id, data: JSON.parse(item.data), id: item.id, proposal: item.proposal && item.proposal.id, timestamp: item.timestamp, type: item.type, user: item.user } } Implement the public static search method, which follows the signature: public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> It typically builds a search query using the GraphQL fragments defined in step 4. This method must return a call to context.getObservableList and its return type should be casted to Observable<Entity> , where entity is the Entity class where this method is being defined. public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> { const itemMap = (arc: Arc, item: any, queriedId?: string) => { const state = Event.itemMap(arc, item, queriedId) return new Event(arc, state) } const query = gql`query EventSearch { events ${createGraphQlQuery(options)} { ...EventFields } } ${Event.fragments.EventFields} ` return context.getObservableList(context, query, itemMap, options.where?.id, apolloQueryOptions) as Observable<Event[]> } Implement the public state method. This method queries the subgraph for the entity based on its ID, to retrieve its state. The method must return a this.context.getObservableObject call. public state(apolloQueryOptions: IApolloQueryOptions = {}): Observable<IEventState> { const query = gql` query EventState { event (id: \"${this.id}\") { ...EventFields } } ${Event.fragments.EventFields} ` return this.context.getObservableObject(this.context, query, Event.itemMap, this.id, apolloQueryOptions) } Export this class in the ./src/index.ts file, using export * from syntax. It is important to note all imports from this library must be imported from the ./src/index.ts file. Adding a Plugin Adding a plugin is similar to adding an entity, with the following differences: The interface that defines the Entity state must extend IPluginState interface. Typically it just adds the pluginParams field. export interface IGenericPluginState extends IPluginState { pluginParams: { votingMachine: Address contractToCall: Address voteParams: IGenesisProtocolParams } } Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. If the Plugin can create Proposals , then the added plugin must extend from abstract class ProposalPlugin<IPluginState, IProposalState, IProposalCreateOptions> IPluginState is the interface defined in the previous step. IProposalState is the interface that defines the state of the proposal that can be created by the plugin. IProposalCreateOptions is the interface that defines the options passed to create a proposal using the plugin. If the Plugin cannot create Proposals , then it must extend from the Plugin<IPluginState> abstract class. If the plugin has fields that should be queried in the Plugin 's class baseFragment query, then it must define a public static fragment field which has the following signature: public static fragment: { name: string, fragment: DocumentNode } name is the name of the GraphQL fragment. It must match the name used in the fragment definition. fragment is the actual GraphQL fragment. public static fragment = { name: 'GenericpluginParams', fragment: gql` fragment GenericpluginParams on ControllerScheme { genericSchemeParams { votingMachine contractToCall voteParams { queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } } ` } The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. Adding a Proposal Adding a Proposal follows similar rules to adding a Plugin , noting that created Proposal classes must be exported in the same way plugins are. Testing run a specific test: npm run test -- test/arc.spec.ts Or watch: npm run test -- --watch Commands npm run build : Generate bundles and typings, create docs npm run lint : Lints code npm run test : run all tests","title":"Developing"},{"location":"stack/arcjs/development/#developing","text":"For development, it is useful to have local instances of Ganache (an ethereum node), IPFS (which is used to store data), an instance of The Graph with the DAOStack subgraph. The package is provided with convenient docker containers that provide a complete environment for testing and development: Get all services running: docker-compose up This command will build and start a graph instance, ganache, IPFS and postgresql. To run the tests, run: npm run test You may also want to run the (demo.js)[./documentation/demo.js] file for some concrete examples of the usage of the library: node documentation/demo.js After you are done, run: docker-compose down","title":"Developing"},{"location":"stack/arcjs/development/#adding-an-entity","text":"The Event entity will be used as example in this section. To add an entity to the library, you must: Create an interface that defines the entity state. export interface IEventState { id: string dao: string proposal: string user: string type: string data: { [key: string]: any } timestamp: string } Create an interface that defines the possible options to query the entity. This interface must extend the ICommonQueryOptions interface. export interface IEventQueryOptions extends ICommonQueryOptions { where?: { id?: string; dao?: Address; proposal?: string; user?: Address; [key: string]: any; } } Create the entity class. This class must extend the Entity<TState> abstract class, where TState is the interface created in step 1. Implement the public static fragments field. Here you can define entity related GraphQL fragments to use in GraphQL queries. public static fragments = { EventFields: gql` fragment EventFields on Event { id dao { id } type data user proposal { id } timestamp } ` } Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): IEntityState The goal of this method is to map the item object received by a query to an object of its interface. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. public static itemMap(context: Arc, item: any, queriedId?: string): IEventState { if (!item) { throw Error(`Event ItemMap failed. ${queriedId ? `Could not find Event with id '${queriedId}'` : ''}`) } return { dao: item.dao.id, data: JSON.parse(item.data), id: item.id, proposal: item.proposal && item.proposal.id, timestamp: item.timestamp, type: item.type, user: item.user } } Implement the public static search method, which follows the signature: public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> It typically builds a search query using the GraphQL fragments defined in step 4. This method must return a call to context.getObservableList and its return type should be casted to Observable<Entity> , where entity is the Entity class where this method is being defined. public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> { const itemMap = (arc: Arc, item: any, queriedId?: string) => { const state = Event.itemMap(arc, item, queriedId) return new Event(arc, state) } const query = gql`query EventSearch { events ${createGraphQlQuery(options)} { ...EventFields } } ${Event.fragments.EventFields} ` return context.getObservableList(context, query, itemMap, options.where?.id, apolloQueryOptions) as Observable<Event[]> } Implement the public state method. This method queries the subgraph for the entity based on its ID, to retrieve its state. The method must return a this.context.getObservableObject call. public state(apolloQueryOptions: IApolloQueryOptions = {}): Observable<IEventState> { const query = gql` query EventState { event (id: \"${this.id}\") { ...EventFields } } ${Event.fragments.EventFields} ` return this.context.getObservableObject(this.context, query, Event.itemMap, this.id, apolloQueryOptions) } Export this class in the ./src/index.ts file, using export * from syntax. It is important to note all imports from this library must be imported from the ./src/index.ts file.","title":"Adding an Entity"},{"location":"stack/arcjs/development/#adding-a-plugin","text":"Adding a plugin is similar to adding an entity, with the following differences: The interface that defines the Entity state must extend IPluginState interface. Typically it just adds the pluginParams field. export interface IGenericPluginState extends IPluginState { pluginParams: { votingMachine: Address contractToCall: Address voteParams: IGenesisProtocolParams } } Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. If the Plugin can create Proposals , then the added plugin must extend from abstract class ProposalPlugin<IPluginState, IProposalState, IProposalCreateOptions> IPluginState is the interface defined in the previous step. IProposalState is the interface that defines the state of the proposal that can be created by the plugin. IProposalCreateOptions is the interface that defines the options passed to create a proposal using the plugin. If the Plugin cannot create Proposals , then it must extend from the Plugin<IPluginState> abstract class. If the plugin has fields that should be queried in the Plugin 's class baseFragment query, then it must define a public static fragment field which has the following signature: public static fragment: { name: string, fragment: DocumentNode } name is the name of the GraphQL fragment. It must match the name used in the fragment definition. fragment is the actual GraphQL fragment. public static fragment = { name: 'GenericpluginParams', fragment: gql` fragment GenericpluginParams on ControllerScheme { genericSchemeParams { votingMachine contractToCall voteParams { queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } } ` } The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file.","title":"Adding a Plugin"},{"location":"stack/arcjs/development/#adding-a-proposal","text":"Adding a Proposal follows similar rules to adding a Plugin , noting that created Proposal classes must be exported in the same way plugins are.","title":"Adding a Proposal"},{"location":"stack/arcjs/development/#testing","text":"run a specific test: npm run test -- test/arc.spec.ts Or watch: npm run test -- --watch","title":"Testing"},{"location":"stack/arcjs/development/#commands","text":"npm run build : Generate bundles and typings, create docs npm run lint : Lints code npm run test : run all tests","title":"Commands"},{"location":"stack/arcjs/intro/","text":"","title":"Quick Example"},{"location":"stack/infra/holographic-consensus/","text":"Genesis Protocol Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article What is Staking? For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted. How does proposal state changes after staking? An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true. Staking Rewards Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost Caveats For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Holographic Consensus"},{"location":"stack/infra/holographic-consensus/#genesis-protocol","text":"Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article","title":"Genesis Protocol"},{"location":"stack/infra/holographic-consensus/#what-is-staking","text":"For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted.","title":"What is Staking?"},{"location":"stack/infra/holographic-consensus/#how-does-proposal-state-changes-after-staking","text":"An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true.","title":"How does proposal state changes after staking?"},{"location":"stack/infra/holographic-consensus/#staking-rewards","text":"Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost","title":"Staking Rewards"},{"location":"stack/infra/holographic-consensus/#caveats","text":"For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Caveats"},{"location":"stack/infra/intro/","text":"Infra Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Intro"},{"location":"stack/infra/intro/#infra","text":"Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Infra"},{"location":"stack/subgraph/entities/","text":"","title":"Entities"},{"location":"stack/subgraph/intro/","text":"","title":"Intro"},{"location":"stack/subgraph/queries/","text":"","title":"GraphQL queries"},{"location":"tutorials/arc-react/","text":"Arc.react Arc.react it's a react library that exposes arc.js functions and subgraph data in react components. Making it easier to develop on top of DAOstack, because it allows the developer to: Build DAOs faster, easier, and better: Enables easy react application deployment and integration, and significantly simplifies building of custom DAO UIs, interfaces, pages, and website native UI. Create a better flow for projects/DAOs looking to onboard streams of new users Take the DAOs where the audience already is, instead of forcing them to come to another app (i.e: Alchemy) Before going forward with how to use the library in your application, we recommend reading the architecture and examples docs so you have a preview of how the library works. Also, as this tutorial go, you can check the api documentation so you can see every component in depth. To add this library into your react app you need to install it first: npm i --save @daostack/arc.react As second step, you will need to connect Arc protocol to React with the Arc component. The Arc is similar to React's Context.Provider. It wraps your React app and places the client on the context, which enables you to access it from anywhere in your component tree. We suggest putting Arc somewhere high in your app, above any component from arc.react library, because, since it's the one that allows the app to connect to the Arc protocol, all components are dependent of it (If you are familiar with @apollo/client library, you can see it as if this is the ApolloProvider object, that wraps the entire application in it). You connect to the Arc protocol using and ArcConfig object like so (please check Protocol connection to get more information about it): import { Arc, ArcConfig } from \"@daostack/arc.react\"; <Arc config={new ArcConfig(\"rinkeby\")}>All other components go here</Arc>; And the last step to connecting your DAO into your app, you need to use the DAO component, passing the address of your DAO as a prop, like this: import { DAO } from \"@daostack/arc.react\"; <DAO address=\"0xMY_DAO\">Your app</DAO>; Now you are ready to code your react app that interacts with Arc protocol! At the end the application should look like this: import { Arc, ArcConfig, DAO } from \"@daostack/arc.react\"; const App = () => { const arcConfig = new ArcConfig(\"rinkeby\"); return ( <Arc config={arcConfig}> <DAO address=\"0xMY_DAO\">Here goes your app!</DAO> </Arc> ); }; Now you can see the members of your DAO: <Members> <Member.Data>{(data: MemberData) => <div>{data.address}</div>}</Member.Data> </Members> And the proposals: <Proposals> <Proposal.Data> <Proposal.Entity> {(data: ProposalData, entity: ProposalEntity) => ( <div> <h1>{data.title}</h1> <button onClick={() => entity.vote({...})}> Up Vote </button> <button onClick={() => entity.vote({...})}> Down Vote </button> </div> )} </Proposal.Entity> </Proposal.Data> </Proposals> And any other entity within the DAOstack protocol ! You can check the demo application built with arc.react on this repository: https://github.com/dOrgTech/arc.react-demo","title":"Arc.react"},{"location":"tutorials/arc-react/#arcreact","text":"Arc.react it's a react library that exposes arc.js functions and subgraph data in react components. Making it easier to develop on top of DAOstack, because it allows the developer to: Build DAOs faster, easier, and better: Enables easy react application deployment and integration, and significantly simplifies building of custom DAO UIs, interfaces, pages, and website native UI. Create a better flow for projects/DAOs looking to onboard streams of new users Take the DAOs where the audience already is, instead of forcing them to come to another app (i.e: Alchemy) Before going forward with how to use the library in your application, we recommend reading the architecture and examples docs so you have a preview of how the library works. Also, as this tutorial go, you can check the api documentation so you can see every component in depth. To add this library into your react app you need to install it first: npm i --save @daostack/arc.react As second step, you will need to connect Arc protocol to React with the Arc component. The Arc is similar to React's Context.Provider. It wraps your React app and places the client on the context, which enables you to access it from anywhere in your component tree. We suggest putting Arc somewhere high in your app, above any component from arc.react library, because, since it's the one that allows the app to connect to the Arc protocol, all components are dependent of it (If you are familiar with @apollo/client library, you can see it as if this is the ApolloProvider object, that wraps the entire application in it). You connect to the Arc protocol using and ArcConfig object like so (please check Protocol connection to get more information about it): import { Arc, ArcConfig } from \"@daostack/arc.react\"; <Arc config={new ArcConfig(\"rinkeby\")}>All other components go here</Arc>; And the last step to connecting your DAO into your app, you need to use the DAO component, passing the address of your DAO as a prop, like this: import { DAO } from \"@daostack/arc.react\"; <DAO address=\"0xMY_DAO\">Your app</DAO>; Now you are ready to code your react app that interacts with Arc protocol! At the end the application should look like this: import { Arc, ArcConfig, DAO } from \"@daostack/arc.react\"; const App = () => { const arcConfig = new ArcConfig(\"rinkeby\"); return ( <Arc config={arcConfig}> <DAO address=\"0xMY_DAO\">Here goes your app!</DAO> </Arc> ); }; Now you can see the members of your DAO: <Members> <Member.Data>{(data: MemberData) => <div>{data.address}</div>}</Member.Data> </Members> And the proposals: <Proposals> <Proposal.Data> <Proposal.Entity> {(data: ProposalData, entity: ProposalEntity) => ( <div> <h1>{data.title}</h1> <button onClick={() => entity.vote({...})}> Up Vote </button> <button onClick={() => entity.vote({...})}> Down Vote </button> </div> )} </Proposal.Entity> </Proposal.Data> </Proposals> And any other entity within the DAOstack protocol ! You can check the demo application built with arc.react on this repository: https://github.com/dOrgTech/arc.react-demo","title":"Arc.react"},{"location":"tutorials/create-a-dao/","text":"DAO creator DAOcreator is a tool that allows you to deploy your DAO in a super simple way. It has a UI which you can find in Alchemy dApp When you create a DAO, it create an instance of the multiple components defined in Arc Deploying a DAO with this tool consists of three steps which are: 1- Set the DAO name and symbol 2- Configure proposals parameters 3- Define the members of your organization Let's go step by step and what they are about: Setting the DAO name and symbol In this section, you will set the DAO's name and the Token's symbol. Configure proposals parameters Here you will define the mechanics of the proposals, from here you can choose the amount of time allotted for votes to come to a close when it comes to making decisions. Choose \u201cSlow\u201d, \u201cMedium\u201d, or \u201cFast\u201d depending on how long you want the voting periods to be. If you\u2019d like to know how long each setting is, simply hover over the buttons to know how many days are given for each type of vote. Then you can choose to add three options, which are: Reward successful proposer: If the proposal passes, the proposer will get a certain amount of REP Reward correct voters and penalize incorrect voters: If the proposal is boosted, the stakers that did the bet for the winning result will get a certain amount of REP Auto-incentivize proposal curation: When a proposal is created, the organization will bet agaisnt the proposal If you are a experienced user in the stack the advanced configuration allows you to configure the voting mechanics as you desire. Please refer to Genesis Protocol documentation to know what the parameters are and what they do. Define the members Here you will be able to add the addresses of whichever members you would like to be a part of the DAO. You will be able to vote to add more members at a later date, but if you have their addresses now, it\u2019s best to get that done now. Each member will be identified by their eth address, so make sure each one is inserted correctly. Misc Export/Import config The DAOcreator allows you to import/export the entire configuration of your DAO. In case you already have your set up but want to send it to someone or wait for another address. You can get the migration-params.json file from the Export configuration button. Import members On the Add members section, there is a button at the top right, that allows you to import a CSV with the members. You can check how to create this CSV in this example","title":"Create your own DAO"},{"location":"tutorials/create-a-dao/#dao-creator","text":"DAOcreator is a tool that allows you to deploy your DAO in a super simple way. It has a UI which you can find in Alchemy dApp When you create a DAO, it create an instance of the multiple components defined in Arc Deploying a DAO with this tool consists of three steps which are: 1- Set the DAO name and symbol 2- Configure proposals parameters 3- Define the members of your organization Let's go step by step and what they are about:","title":"DAO creator"},{"location":"tutorials/create-a-dao/#setting-the-dao-name-and-symbol","text":"In this section, you will set the DAO's name and the Token's symbol.","title":"Setting the DAO name and symbol"},{"location":"tutorials/create-a-dao/#configure-proposals-parameters","text":"Here you will define the mechanics of the proposals, from here you can choose the amount of time allotted for votes to come to a close when it comes to making decisions. Choose \u201cSlow\u201d, \u201cMedium\u201d, or \u201cFast\u201d depending on how long you want the voting periods to be. If you\u2019d like to know how long each setting is, simply hover over the buttons to know how many days are given for each type of vote. Then you can choose to add three options, which are: Reward successful proposer: If the proposal passes, the proposer will get a certain amount of REP Reward correct voters and penalize incorrect voters: If the proposal is boosted, the stakers that did the bet for the winning result will get a certain amount of REP Auto-incentivize proposal curation: When a proposal is created, the organization will bet agaisnt the proposal If you are a experienced user in the stack the advanced configuration allows you to configure the voting mechanics as you desire. Please refer to Genesis Protocol documentation to know what the parameters are and what they do.","title":"Configure proposals parameters"},{"location":"tutorials/create-a-dao/#define-the-members","text":"Here you will be able to add the addresses of whichever members you would like to be a part of the DAO. You will be able to vote to add more members at a later date, but if you have their addresses now, it\u2019s best to get that done now. Each member will be identified by their eth address, so make sure each one is inserted correctly.","title":"Define the members"},{"location":"tutorials/create-a-dao/#misc","text":"","title":"Misc"},{"location":"tutorials/create-a-dao/#exportimport-config","text":"The DAOcreator allows you to import/export the entire configuration of your DAO. In case you already have your set up but want to send it to someone or wait for another address. You can get the migration-params.json file from the Export configuration button.","title":"Export/Import config"},{"location":"tutorials/create-a-dao/#import-members","text":"On the Add members section, there is a button at the top right, that allows you to import a CSV with the members. You can check how to create this CSV in this example","title":"Import members"},{"location":"tutorials/generic-plugin/","text":"Registering a generic plugin If you have a contract that is already deployed and would like it to interact with your DAO, creating a Generic Plugin is your solution! You just need to add your plugin via the Plugin Manager, this will create a new proposal and once it passes, it will allow you to interact with the contract through alchemy dApp: If the contract to call has not been added yet into alchemy (which means you selected custom and added an address), you will need to fork the repository in order to interact with your new plugin in a user friendly way! The steps are the following: 1.- Add an interface of your contract to alchemy : You will need to create a YOUR_CONTRACT_NAME.json file in /src/genericPluginRegistry/plugins/ . This file will contain three main fields: name : The name of your contract addresses : This will be an object in which you will add the address of the target contract (or the address you want your DAO to interact with!). Please check the example linked below to get a reference on how it should be. actions : This is the way you customize your proposal form. Here, you add an array of the actions (functions) you want your DAO to be able to execute on the contract to call, it needs to have the following keys: id : The ID of the action in the dApp (Should be the name of the method in the contract) label : The name of action that will appear in the dApp description : Will tell your users what to expect from this action notes : Url of the contract's code fields : These are the arguments of the method the user will interact with when they create a proposal, it's an array, since you can add as many inputs as you desire. The fields will have three keys, which are: label : Description of the argument in the UI name : Name of the argument in the contract placeholder : A placeholder for the input, can be an example of what the user should enter abi : The ABI of the method of the contract Check this example for more information! The last to do on this step is going to /src/genericPluginRegistry/index.ts , import your JSON and add it into the array of KNOWNPLUGINS So far, you have created a good interface to allow your users to create new proposals in your generic scheme, now let's show this proposals in a good looking way 2.- Create the view of proposal summary for your Generic plugin :","title":"Register a generic plugin"},{"location":"tutorials/generic-plugin/#registering-a-generic-plugin","text":"If you have a contract that is already deployed and would like it to interact with your DAO, creating a Generic Plugin is your solution! You just need to add your plugin via the Plugin Manager, this will create a new proposal and once it passes, it will allow you to interact with the contract through alchemy dApp: If the contract to call has not been added yet into alchemy (which means you selected custom and added an address), you will need to fork the repository in order to interact with your new plugin in a user friendly way! The steps are the following: 1.- Add an interface of your contract to alchemy : You will need to create a YOUR_CONTRACT_NAME.json file in /src/genericPluginRegistry/plugins/ . This file will contain three main fields: name : The name of your contract addresses : This will be an object in which you will add the address of the target contract (or the address you want your DAO to interact with!). Please check the example linked below to get a reference on how it should be. actions : This is the way you customize your proposal form. Here, you add an array of the actions (functions) you want your DAO to be able to execute on the contract to call, it needs to have the following keys: id : The ID of the action in the dApp (Should be the name of the method in the contract) label : The name of action that will appear in the dApp description : Will tell your users what to expect from this action notes : Url of the contract's code fields : These are the arguments of the method the user will interact with when they create a proposal, it's an array, since you can add as many inputs as you desire. The fields will have three keys, which are: label : Description of the argument in the UI name : Name of the argument in the contract placeholder : A placeholder for the input, can be an example of what the user should enter abi : The ABI of the method of the contract Check this example for more information! The last to do on this step is going to /src/genericPluginRegistry/index.ts , import your JSON and add it into the array of KNOWNPLUGINS So far, you have created a good interface to allow your users to create new proposals in your generic scheme, now let's show this proposals in a good looking way 2.- Create the view of proposal summary for your Generic plugin :","title":"Registering a generic plugin"},{"location":"tutorials/register-a-plugin/alchemy/","text":"Registering a Plugin in Alchemy Registering the plugin's name In the pluginUtils.ts file, typically under src/lib , there's a PLUGIN_NAMES object: export const PLUGIN_NAMES = { ContributionReward: \"Funding and Voting Power\", GenericScheme: \"Generic Plugin\", ReputationFromToken: \"Reputation from Token\", SchemeRegistrar: \"Plugin Registrar\", SchemeFactory: \"Plugin Manager\", Competition: \"Competition\", TokenTrade: \"Token Trade\", ContributionRewardExt: \"Contribution Reward Ext\", Join: \"Join\", FundingRequest: \"Funding Request\", }; Add the new plugin to that object. Creating the CreateProposal form component Alchemy typically uses class based React components. And the naming convention is usually: Create + Plugin Name + Proposal. Example: CreateContributionRewardProposal . 1. Declaring Form Values The first step is to declare an IFormValues interface that describes all of the Create Proposal form fields . This interface should always contain at least the following properties: interface IFormValues { description: string; title: string; url: string; tags: Array<string> } A full example of this interface can be found in the CreateTokenTradeProposal component: interface IFormValues { description: string; title: string; url: string; tags: Array<string>; sendTokenAddress: string, sendTokenAmount: number, receiveTokenAddress: string, receiveTokenAmount: number, } The next step is to create a function that returns an IFormValues object with the proper initial values of each field. Following the CreateTokenTradeProposal 's IFormValues example, its initializing function would be: const setInitialFormValues = (): IFormValues => { return Object.freeze({ description: \"\", title: \"\", url: \"\", tags: [], sendTokenAddress: \"\", sendTokenAmount: 0, receiveTokenAddress: \"\", receiveTokenAmount: 0, }); }; Lastly, declare a currentFormValues class property of type IFormValues in the CreateProposal component: class CreateExamplePluginProposal extends React.Component<IProps, IState> { currentFormValues: IFormValues; constructor(props: IProps) { super(props); ... } ... } 2. Creating a FormModalService instance Alchemy's CreateProposal form components make use of the FormModalService , which handles form state changes and notifications. To use it, an instance of it is typically declared as a class property and created in the constructor: class CreateExamplePluginProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } From the example above, you will notice the CreateFormModalService function takes 5 arguments: formName defaultValues valuesToPersist updateCurrentValues showNotification 3. Initializing the state object Sometimes it is necessary to persist form-relevant values across re-renders, that are not directly form values. Like an array with all possible dropdown options. This is always the case with proposal tags. Therefore, they should always be initialized in the constructor like this: class CreateTokenTradeProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.state = { tags: [] }; this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } 4. Creating the form's markup Inside the class Component's render function a Formik component should be declared. This component takes 4 arguments: initialValues : we will pass this.currentFormValues here. validate : we will pass a Formik validation function here, like this one: (values: IFormValues) => { this.currentFormValues = values; const errors: any = {}; const require = (name: string) => { if (!(values as any)[name]) { errors[name] = \"Required\"; } }; require(\"description\"); require(\"title\"); if (values.title.length > 120) { errors.title = \"Title is too long (max 120 characters)\"; } if (!isValidUrl(values.url)) { errors.url = \"Invalid URL\"; } return errors; } onSubmit : we will pass the class's handleSubmit method (explained in detail in the following sections). render : here is where the actual CreateProposal form's markup will live. Here we pass a functional component that has all form relevant props injected by Formik and will return the form's markup: ({ errors, touched, isSubmitting, setFieldValue, values, }: FormikProps<IFormValues>) => { return ( <Form noValidate> <label className={css.description}>What to Expect</label> <div className={css.description}>Propose to trade tokens with the DAO.</div> <TrainingTooltip overlay={i18next.t(\"Title Tooltip\")} placement=\"right\"> <label htmlFor=\"titleInput\"> <div className={css.requiredMarker}>*</div> Title <ErrorMessage name=\"title\">{(msg) => <span className={css.errorMessage}>{msg}</span>}</ErrorMessage> </label> </TrainingTooltip> <Field autoFocus id=\"titleInput\" maxLength={120} placeholder={i18next.t(\"Title Placeholder\")} name=\"title\" type=\"text\" className={touched.title && errors.title ? css.error : null} /> ... </Form> )} } It is worth noting the following conventions to write the form's markup: i18next should be used for all form labels, notifications and messages. There should be a TrainingTooltip component above each Field with a description relevant to said field. Styling is declared in a separate Sass file. 5. Creating the handleSubmit method This method should be private and asynchronous. It, mainly, checks if the Wallet Provider is enabled, maps form values to an Arc.js proposalOptions object, awaits proposal creation through an Arc.js createProposal call, and tracks analytics on proposal submission. A full example of this is the TokenTrade 's handleSubmit method: private handleSubmit = async (values: IFormValues, { setSubmitting }: any ): Promise<void> => { if (!await enableWalletProvider({ showNotification: this.props.showNotification })) { return; } const proposalOptions = { dao: this.props.daoAvatarAddress, description: values.description, title: values.title, tags: this.state.tags, plugin: this.props.pluginState.address, url: values.url, sendTokenAddress: values.sendTokenAddress, sendTokenAmount: values.sendTokenAmount, receiveTokenAddress: values.receiveTokenAddress, receiveTokenAmount: values.receiveTokenAmount, }; setSubmitting(false); await this.props.createProposal(proposalOptions); Analytics.track(\"Submit Proposal\", { \"DAO Address\": this.props.daoAvatarAddress, \"Proposal Title\": values.title, \"Plugin Address\": this.props.pluginState.address, \"Plugin Name\": this.props.pluginState.name, }); this.props.handleClose(); } It is worth mentioning that dao address and plugin address options are taken from the component's props. More on this in the following sections. Registering the Form For this component to be used it needs to be added to the CreateProposalPage.tsx file. Go to this file, typically under src/components/Proposal/Create . You will notice the CreateProposalPage component: class CreateProposalPage extends React.Component<IProps, IStateProps> { constructor(props: IProps) { super(props); this.state = { createCrxProposalComponent: null, }; } ... public render(): RenderOutput { const { daoAvatarAddress, currentAccountAddress } = this.props; const plugin = this.props.data; const pluginState = plugin.coreState; let createPluginComponent = <div />; const props = { currentAccountAddress, daoAvatarAddress, handleClose: this.doClose, plugin, }; const pluginTitle = this.state.createCrxProposalComponent ? rewarderContractName(pluginState as IContributionRewardExtState) : pluginName(pluginState); if (this.state.createCrxProposalComponent) { createPluginComponent = <this.state.createCrxProposalComponent {...props} />; } else if (pluginState.name === \"ContributionReward\") { createPluginComponent = <CreateContributionRewardProposal {...props} pluginState={pluginState as IContributionRewardState} />; } else if (pluginState.name === \"SchemeRegistrar\") { createPluginComponent = <CreatePluginRegistrarProposal {...props} pluginState={pluginState as IPluginRegistrarState} />; } else if (pluginState.name === \"SchemeFactory\") { createPluginComponent = <CreatePluginManagerProposal {...props} pluginState={pluginState as IPluginManagerState} />; } else if (pluginState.name === \"TokenTrade\") { createPluginComponent = <CreateTokenTradeProposal {...props} pluginState={pluginState as ITokenTradeState} />; } else if (pluginState.name === \"GenericScheme\") { const contractToCall = (pluginState as IGenericPluginState).pluginParams.contractToCall; if (!contractToCall) { throw Error(\"No contractToCall for this genericPlugin was found!\"); } const genericPluginRegistry = new GenericPluginRegistry(); const genericPluginInfo = genericPluginRegistry.getPluginInfo(contractToCall); if (genericPluginInfo) { createPluginComponent = <CreateKnownGenericPluginProposal {...props} genericPluginInfo={genericPluginInfo} pluginState={pluginState as IGenericPluginState} />; } else { createPluginComponent = <CreateUnknownGenericPluginProposal {...props} pluginState={pluginState as IGenericPluginState} />; } } ... } } Then on the render method of the CreateProposalPage declared there, add a condition to make the createPluginComponent variable be the CreateProposalForm you created in the previous section, if the pluginState's name matches the proposal's plugin. Your CreateProposalForm component in this method will take the CreateProposalPage 's deconstructed props: {...props} and a pluginState object which must be casted to an Arc.js Plugin State interface. Make created proposal redeemable In order to make a proposal created through your CreateProposalForm redeemable, you must register it in the arcActions file. Typically under: src/actions , the file will contain a tryRedeemProposal function: async function tryRedeemProposal(proposalId: string, accountAddress: string, observer: any) { const arc = getArc(); const proposal = await Proposal.create(arc, proposalId); switch (proposal.coreState.name) { case \"GenericScheme\": case \"ContributionReward\": case \"Competition\": case \"ContributionRewardExt\": case \"SchemeRegistrarRemove\": case \"SchemeRegistrarAdd\": case \"SchemeRegistrar\": case \"SchemeFactory\": await (proposal as Proposal<IProposalState>).redeemRewards( accountAddress ).subscribe(...observer); break; case \"FundingRequest\": await (proposal as FundingRequestProposal).redeem().subscribe(...observer); break; case \"Join\": await (proposal as JoinProposal).redeem().subscribe(...observer); break; case \"TokenTrade\": await (proposal as TokenTradeProposal).redeem().subscribe(...observer); break; default: break; } return Promise.resolve(); } There, add a case to the already existing switch , with the proposal's plugin name. Inside, cast the proposal object to the corresponding Arc.js Proposal Class, call redeem and subscribe on it and await it, just like in the example above. Registering the plugin in the Plugin Manager In the PluginManager 's CreateProposal form, the following additions are needed so that the new plugin can be created from a plugin manager proposal: In the plugin manager's IFormValues interface: export interface IFormValues { description: string; currentTab: ITab; tags: Array<string>; title: string; url: string; pluginToRemove: string; pluginToAdd: PluginNames | \"\"; GenericScheme: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; contractToCall: string; }; ContributionReward: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; Competition: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; ... } add the new plugin's initialize parameters. In the plugin manager's defaultValues object, declare the initial default values for the initialize parameters declared in the previous step: const defaultValues: IFormValues = { description: \"\", pluginToAdd: \"\", pluginToRemove: \"\", title: \"\", url: \"\", currentTab: \"addPlugin\", tags: [], GenericScheme: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: true, }, contractToCall: \"\", }, ContributionReward: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: false, }, }, ... } In the plugin manager's handleSubmit method, add a case to the already existing switch for creation and replacement proposals. The case added must populate the plugin's initialize parameters: if (currentTab === \"addPlugin\" || currentTab === \"replacePlugin\") { (proposalOptions.add as any) = { pluginName: values.pluginToAdd, }; switch (proposalOptions.add.pluginName) { case \"Competition\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.Competition.votingParams), voteOnBehalf: values.Competition.votingParams.voteOnBehalf, voteParamsHash: values.Competition.votingParams.voteParamsHash, daoFactory: arc.getContractInfoByName(\"DAOFactoryInstance\", LATEST_ARC_VERSION).address, packageVersion: packageVersion, rewarderName: \"Competition\", }; break; case \"ContributionReward\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.ContributionReward.votingParams), voteOnBehalf: values.ContributionReward.votingParams.voteOnBehalf, voteParamsHash: values.ContributionReward.votingParams.voteParamsHash, }; break; ... } ... } Additionally, so that the plugin manager's form can properly render the initialize parameters fields for the new plugin, go to the PluginInitializeFields.ts file, typically under src/components/Proposal/Create : ... const TokenTrade = () => ( <div> {GenesisProtocolFields(\"TokenTrade.votingParams\")} </div> ); const ReputationFromTokenFields = () => ( <div> {fieldView(\"ReputationFromToken\", \"Token Contract\", \"tokenContract\")} {fieldView(\"ReputationFromToken\", \"Curve Interface\", \"curveInterface\")} </div> ); const fieldsMap = { GenericScheme: GenericSchemeFields, ContributionReward: ContributionRewardFields, Competition: CompetitionFields, ContributionRewardExt: ContributionRewardExtFields, FundingRequest: FundingRequest, Join: Join, TokenTrade: TokenTrade, SchemeRegistrar: SchemeRegistrarFields, SchemeFactory: PluginManagerFields, ReputationFromToken: ReputationFromTokenFields, }; ... There, 2 additions are necessary: Create a function that returns each initialize parameter field for the new plugin. This is done, using the fieldView function that takes 3 arguments: pluginName, initializeParameterName, fieldName. See the code snippet above. Add the created funcion to the fieldsMap object. Create the Proposal Summary page Each plugin should have its ProposalSummary page along with its CreateProposal form. This summary will contain the relevant proposal information that will be shown after the proposal has been created. It follows a simple class based Component pattern. For example, TokenTrade 's proposal summary looks like this: export default class ProposalSummaryTokenTrade extends React.Component<IProps> { constructor(props: IProps) { super(props); } public render(): RenderOutput { const { beneficiaryProfile, proposalState, daoState, detailView, transactionModal } = this.props; let receiveToken; let sendToken; if (proposalState.sendTokenAddress && proposalState.sendTokenAmount) { const tokenData = tokenDetails(proposalState.sendTokenAddress); sendToken = formatTokens(toWei(Number(proposalState.sendTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } if (proposalState.receiveTokenAddress && proposalState.receiveTokenAmount) { const tokenData = tokenDetails(proposalState.receiveTokenAddress); receiveToken = formatTokens(toWei(Number(proposalState.receiveTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); return ( <div className={proposalSummaryClass}> <span className={css.transferType}> { sendToken && <div> <div> <span className={css.bold}>{i18next.t(\"Send to DAO\")}:</span> </div> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> {receiveToken} </div> } { receiveToken && <div> <div> <span className={css.bold}>{i18next.t(\"Receive from DAO\")}:</span> </div> {receiveToken} <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> </div> } </span> </div> ); } } It is worth noting: All labels and messages use i18next Css is declared separately There are already handy components like AccountPopup and AccountProfileName to display Account information consistently. Registering the Proposal Summary Page In the ProposalSummary.tsx file, typically under src/components/Proposal/ProposalSummary : export default class ProposalSummary extends React.Component<IProps, IState> { ... public render(): RenderOutput { if (!this.state) { return null; } const { detailView, transactionModal } = this.props; const { proposal } = this.state; const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); if (proposal.coreState.name === \"ContributionReward\") { const state = proposal.coreState as IContributionRewardProposalState; return <ProposalSummaryContributionReward {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"SchemeRegistrar\")) { const state = proposal.coreState as IPluginRegistrarProposalState; return <ProposalSummaryPluginRegistrar {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"TokenTrade\")) { const state = proposal.coreState as ITokenTradeProposalState; return <ProposalSummaryTokenTrade {...this.props} proposalState={state} />; } ... } Add a condition that will handle the case where the proposal's state name matches the new plugin's name. Inside this condition cast the proposal.coreState to the corresponding Arc.js ProposalState class. Then return the ProposalSummary component created on the previous section, and pass as props {...this.props} and a proposalState object which will be the casted proposal.coreState .","title":"Alchemy"},{"location":"tutorials/register-a-plugin/alchemy/#registering-a-plugin-in-alchemy","text":"","title":"Registering a Plugin in Alchemy"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-plugins-name","text":"In the pluginUtils.ts file, typically under src/lib , there's a PLUGIN_NAMES object: export const PLUGIN_NAMES = { ContributionReward: \"Funding and Voting Power\", GenericScheme: \"Generic Plugin\", ReputationFromToken: \"Reputation from Token\", SchemeRegistrar: \"Plugin Registrar\", SchemeFactory: \"Plugin Manager\", Competition: \"Competition\", TokenTrade: \"Token Trade\", ContributionRewardExt: \"Contribution Reward Ext\", Join: \"Join\", FundingRequest: \"Funding Request\", }; Add the new plugin to that object.","title":"Registering the plugin's name"},{"location":"tutorials/register-a-plugin/alchemy/#creating-the-createproposal-form-component","text":"Alchemy typically uses class based React components. And the naming convention is usually: Create + Plugin Name + Proposal. Example: CreateContributionRewardProposal .","title":"Creating the CreateProposal form component"},{"location":"tutorials/register-a-plugin/alchemy/#1-declaring-form-values","text":"The first step is to declare an IFormValues interface that describes all of the Create Proposal form fields . This interface should always contain at least the following properties: interface IFormValues { description: string; title: string; url: string; tags: Array<string> } A full example of this interface can be found in the CreateTokenTradeProposal component: interface IFormValues { description: string; title: string; url: string; tags: Array<string>; sendTokenAddress: string, sendTokenAmount: number, receiveTokenAddress: string, receiveTokenAmount: number, } The next step is to create a function that returns an IFormValues object with the proper initial values of each field. Following the CreateTokenTradeProposal 's IFormValues example, its initializing function would be: const setInitialFormValues = (): IFormValues => { return Object.freeze({ description: \"\", title: \"\", url: \"\", tags: [], sendTokenAddress: \"\", sendTokenAmount: 0, receiveTokenAddress: \"\", receiveTokenAmount: 0, }); }; Lastly, declare a currentFormValues class property of type IFormValues in the CreateProposal component: class CreateExamplePluginProposal extends React.Component<IProps, IState> { currentFormValues: IFormValues; constructor(props: IProps) { super(props); ... } ... }","title":"1. Declaring Form Values"},{"location":"tutorials/register-a-plugin/alchemy/#2-creating-a-formmodalservice-instance","text":"Alchemy's CreateProposal form components make use of the FormModalService , which handles form state changes and notifications. To use it, an instance of it is typically declared as a class property and created in the constructor: class CreateExamplePluginProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } From the example above, you will notice the CreateFormModalService function takes 5 arguments: formName defaultValues valuesToPersist updateCurrentValues showNotification","title":"2. Creating a FormModalService instance"},{"location":"tutorials/register-a-plugin/alchemy/#3-initializing-the-state-object","text":"Sometimes it is necessary to persist form-relevant values across re-renders, that are not directly form values. Like an array with all possible dropdown options. This is always the case with proposal tags. Therefore, they should always be initialized in the constructor like this: class CreateTokenTradeProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.state = { tags: [] }; this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); }","title":"3. Initializing the state object"},{"location":"tutorials/register-a-plugin/alchemy/#4-creating-the-forms-markup","text":"Inside the class Component's render function a Formik component should be declared. This component takes 4 arguments: initialValues : we will pass this.currentFormValues here. validate : we will pass a Formik validation function here, like this one: (values: IFormValues) => { this.currentFormValues = values; const errors: any = {}; const require = (name: string) => { if (!(values as any)[name]) { errors[name] = \"Required\"; } }; require(\"description\"); require(\"title\"); if (values.title.length > 120) { errors.title = \"Title is too long (max 120 characters)\"; } if (!isValidUrl(values.url)) { errors.url = \"Invalid URL\"; } return errors; } onSubmit : we will pass the class's handleSubmit method (explained in detail in the following sections). render : here is where the actual CreateProposal form's markup will live. Here we pass a functional component that has all form relevant props injected by Formik and will return the form's markup: ({ errors, touched, isSubmitting, setFieldValue, values, }: FormikProps<IFormValues>) => { return ( <Form noValidate> <label className={css.description}>What to Expect</label> <div className={css.description}>Propose to trade tokens with the DAO.</div> <TrainingTooltip overlay={i18next.t(\"Title Tooltip\")} placement=\"right\"> <label htmlFor=\"titleInput\"> <div className={css.requiredMarker}>*</div> Title <ErrorMessage name=\"title\">{(msg) => <span className={css.errorMessage}>{msg}</span>}</ErrorMessage> </label> </TrainingTooltip> <Field autoFocus id=\"titleInput\" maxLength={120} placeholder={i18next.t(\"Title Placeholder\")} name=\"title\" type=\"text\" className={touched.title && errors.title ? css.error : null} /> ... </Form> )} } It is worth noting the following conventions to write the form's markup: i18next should be used for all form labels, notifications and messages. There should be a TrainingTooltip component above each Field with a description relevant to said field. Styling is declared in a separate Sass file.","title":"4. Creating the form's markup"},{"location":"tutorials/register-a-plugin/alchemy/#5-creating-the-handlesubmit-method","text":"This method should be private and asynchronous. It, mainly, checks if the Wallet Provider is enabled, maps form values to an Arc.js proposalOptions object, awaits proposal creation through an Arc.js createProposal call, and tracks analytics on proposal submission. A full example of this is the TokenTrade 's handleSubmit method: private handleSubmit = async (values: IFormValues, { setSubmitting }: any ): Promise<void> => { if (!await enableWalletProvider({ showNotification: this.props.showNotification })) { return; } const proposalOptions = { dao: this.props.daoAvatarAddress, description: values.description, title: values.title, tags: this.state.tags, plugin: this.props.pluginState.address, url: values.url, sendTokenAddress: values.sendTokenAddress, sendTokenAmount: values.sendTokenAmount, receiveTokenAddress: values.receiveTokenAddress, receiveTokenAmount: values.receiveTokenAmount, }; setSubmitting(false); await this.props.createProposal(proposalOptions); Analytics.track(\"Submit Proposal\", { \"DAO Address\": this.props.daoAvatarAddress, \"Proposal Title\": values.title, \"Plugin Address\": this.props.pluginState.address, \"Plugin Name\": this.props.pluginState.name, }); this.props.handleClose(); } It is worth mentioning that dao address and plugin address options are taken from the component's props. More on this in the following sections.","title":"5. Creating the handleSubmit method"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-form","text":"For this component to be used it needs to be added to the CreateProposalPage.tsx file. Go to this file, typically under src/components/Proposal/Create . You will notice the CreateProposalPage component: class CreateProposalPage extends React.Component<IProps, IStateProps> { constructor(props: IProps) { super(props); this.state = { createCrxProposalComponent: null, }; } ... public render(): RenderOutput { const { daoAvatarAddress, currentAccountAddress } = this.props; const plugin = this.props.data; const pluginState = plugin.coreState; let createPluginComponent = <div />; const props = { currentAccountAddress, daoAvatarAddress, handleClose: this.doClose, plugin, }; const pluginTitle = this.state.createCrxProposalComponent ? rewarderContractName(pluginState as IContributionRewardExtState) : pluginName(pluginState); if (this.state.createCrxProposalComponent) { createPluginComponent = <this.state.createCrxProposalComponent {...props} />; } else if (pluginState.name === \"ContributionReward\") { createPluginComponent = <CreateContributionRewardProposal {...props} pluginState={pluginState as IContributionRewardState} />; } else if (pluginState.name === \"SchemeRegistrar\") { createPluginComponent = <CreatePluginRegistrarProposal {...props} pluginState={pluginState as IPluginRegistrarState} />; } else if (pluginState.name === \"SchemeFactory\") { createPluginComponent = <CreatePluginManagerProposal {...props} pluginState={pluginState as IPluginManagerState} />; } else if (pluginState.name === \"TokenTrade\") { createPluginComponent = <CreateTokenTradeProposal {...props} pluginState={pluginState as ITokenTradeState} />; } else if (pluginState.name === \"GenericScheme\") { const contractToCall = (pluginState as IGenericPluginState).pluginParams.contractToCall; if (!contractToCall) { throw Error(\"No contractToCall for this genericPlugin was found!\"); } const genericPluginRegistry = new GenericPluginRegistry(); const genericPluginInfo = genericPluginRegistry.getPluginInfo(contractToCall); if (genericPluginInfo) { createPluginComponent = <CreateKnownGenericPluginProposal {...props} genericPluginInfo={genericPluginInfo} pluginState={pluginState as IGenericPluginState} />; } else { createPluginComponent = <CreateUnknownGenericPluginProposal {...props} pluginState={pluginState as IGenericPluginState} />; } } ... } } Then on the render method of the CreateProposalPage declared there, add a condition to make the createPluginComponent variable be the CreateProposalForm you created in the previous section, if the pluginState's name matches the proposal's plugin. Your CreateProposalForm component in this method will take the CreateProposalPage 's deconstructed props: {...props} and a pluginState object which must be casted to an Arc.js Plugin State interface.","title":"Registering the Form"},{"location":"tutorials/register-a-plugin/alchemy/#make-created-proposal-redeemable","text":"In order to make a proposal created through your CreateProposalForm redeemable, you must register it in the arcActions file. Typically under: src/actions , the file will contain a tryRedeemProposal function: async function tryRedeemProposal(proposalId: string, accountAddress: string, observer: any) { const arc = getArc(); const proposal = await Proposal.create(arc, proposalId); switch (proposal.coreState.name) { case \"GenericScheme\": case \"ContributionReward\": case \"Competition\": case \"ContributionRewardExt\": case \"SchemeRegistrarRemove\": case \"SchemeRegistrarAdd\": case \"SchemeRegistrar\": case \"SchemeFactory\": await (proposal as Proposal<IProposalState>).redeemRewards( accountAddress ).subscribe(...observer); break; case \"FundingRequest\": await (proposal as FundingRequestProposal).redeem().subscribe(...observer); break; case \"Join\": await (proposal as JoinProposal).redeem().subscribe(...observer); break; case \"TokenTrade\": await (proposal as TokenTradeProposal).redeem().subscribe(...observer); break; default: break; } return Promise.resolve(); } There, add a case to the already existing switch , with the proposal's plugin name. Inside, cast the proposal object to the corresponding Arc.js Proposal Class, call redeem and subscribe on it and await it, just like in the example above.","title":"Make created proposal redeemable"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-plugin-in-the-plugin-manager","text":"In the PluginManager 's CreateProposal form, the following additions are needed so that the new plugin can be created from a plugin manager proposal: In the plugin manager's IFormValues interface: export interface IFormValues { description: string; currentTab: ITab; tags: Array<string>; title: string; url: string; pluginToRemove: string; pluginToAdd: PluginNames | \"\"; GenericScheme: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; contractToCall: string; }; ContributionReward: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; Competition: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; ... } add the new plugin's initialize parameters. In the plugin manager's defaultValues object, declare the initial default values for the initialize parameters declared in the previous step: const defaultValues: IFormValues = { description: \"\", pluginToAdd: \"\", pluginToRemove: \"\", title: \"\", url: \"\", currentTab: \"addPlugin\", tags: [], GenericScheme: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: true, }, contractToCall: \"\", }, ContributionReward: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: false, }, }, ... } In the plugin manager's handleSubmit method, add a case to the already existing switch for creation and replacement proposals. The case added must populate the plugin's initialize parameters: if (currentTab === \"addPlugin\" || currentTab === \"replacePlugin\") { (proposalOptions.add as any) = { pluginName: values.pluginToAdd, }; switch (proposalOptions.add.pluginName) { case \"Competition\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.Competition.votingParams), voteOnBehalf: values.Competition.votingParams.voteOnBehalf, voteParamsHash: values.Competition.votingParams.voteParamsHash, daoFactory: arc.getContractInfoByName(\"DAOFactoryInstance\", LATEST_ARC_VERSION).address, packageVersion: packageVersion, rewarderName: \"Competition\", }; break; case \"ContributionReward\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.ContributionReward.votingParams), voteOnBehalf: values.ContributionReward.votingParams.voteOnBehalf, voteParamsHash: values.ContributionReward.votingParams.voteParamsHash, }; break; ... } ... } Additionally, so that the plugin manager's form can properly render the initialize parameters fields for the new plugin, go to the PluginInitializeFields.ts file, typically under src/components/Proposal/Create : ... const TokenTrade = () => ( <div> {GenesisProtocolFields(\"TokenTrade.votingParams\")} </div> ); const ReputationFromTokenFields = () => ( <div> {fieldView(\"ReputationFromToken\", \"Token Contract\", \"tokenContract\")} {fieldView(\"ReputationFromToken\", \"Curve Interface\", \"curveInterface\")} </div> ); const fieldsMap = { GenericScheme: GenericSchemeFields, ContributionReward: ContributionRewardFields, Competition: CompetitionFields, ContributionRewardExt: ContributionRewardExtFields, FundingRequest: FundingRequest, Join: Join, TokenTrade: TokenTrade, SchemeRegistrar: SchemeRegistrarFields, SchemeFactory: PluginManagerFields, ReputationFromToken: ReputationFromTokenFields, }; ... There, 2 additions are necessary: Create a function that returns each initialize parameter field for the new plugin. This is done, using the fieldView function that takes 3 arguments: pluginName, initializeParameterName, fieldName. See the code snippet above. Add the created funcion to the fieldsMap object.","title":"Registering the plugin in the Plugin Manager"},{"location":"tutorials/register-a-plugin/alchemy/#create-the-proposal-summary-page","text":"Each plugin should have its ProposalSummary page along with its CreateProposal form. This summary will contain the relevant proposal information that will be shown after the proposal has been created. It follows a simple class based Component pattern. For example, TokenTrade 's proposal summary looks like this: export default class ProposalSummaryTokenTrade extends React.Component<IProps> { constructor(props: IProps) { super(props); } public render(): RenderOutput { const { beneficiaryProfile, proposalState, daoState, detailView, transactionModal } = this.props; let receiveToken; let sendToken; if (proposalState.sendTokenAddress && proposalState.sendTokenAmount) { const tokenData = tokenDetails(proposalState.sendTokenAddress); sendToken = formatTokens(toWei(Number(proposalState.sendTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } if (proposalState.receiveTokenAddress && proposalState.receiveTokenAmount) { const tokenData = tokenDetails(proposalState.receiveTokenAddress); receiveToken = formatTokens(toWei(Number(proposalState.receiveTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); return ( <div className={proposalSummaryClass}> <span className={css.transferType}> { sendToken && <div> <div> <span className={css.bold}>{i18next.t(\"Send to DAO\")}:</span> </div> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> {receiveToken} </div> } { receiveToken && <div> <div> <span className={css.bold}>{i18next.t(\"Receive from DAO\")}:</span> </div> {receiveToken} <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> </div> } </span> </div> ); } } It is worth noting: All labels and messages use i18next Css is declared separately There are already handy components like AccountPopup and AccountProfileName to display Account information consistently.","title":"Create the Proposal Summary page"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-proposal-summary-page","text":"In the ProposalSummary.tsx file, typically under src/components/Proposal/ProposalSummary : export default class ProposalSummary extends React.Component<IProps, IState> { ... public render(): RenderOutput { if (!this.state) { return null; } const { detailView, transactionModal } = this.props; const { proposal } = this.state; const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); if (proposal.coreState.name === \"ContributionReward\") { const state = proposal.coreState as IContributionRewardProposalState; return <ProposalSummaryContributionReward {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"SchemeRegistrar\")) { const state = proposal.coreState as IPluginRegistrarProposalState; return <ProposalSummaryPluginRegistrar {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"TokenTrade\")) { const state = proposal.coreState as ITokenTradeProposalState; return <ProposalSummaryTokenTrade {...this.props} proposalState={state} />; } ... } Add a condition that will handle the case where the proposal's state name matches the new plugin's name. Inside this condition cast the proposal.coreState to the corresponding Arc.js ProposalState class. Then return the ProposalSummary component created on the previous section, and pass as props {...this.props} and a proposalState object which will be the casted proposal.coreState .","title":"Registering the Proposal Summary Page"},{"location":"tutorials/register-a-plugin/arc/","text":"Create a plugin on Arc As we said before, plugins are the DAO's actions, and if you want your DAO (or any DAO) to have a new action you can do it. First of all, you will need to add your new plugin in Arc. This means that you will need to fork the Arc repository , write your custom plugin, and create a PR to the daostack's repository Writing the contracts Let's use as example the TrokenTrade plugin, to show how you should add your custom plugin: You need to create it in the folder schemes . Your contract will need to inherit from VotingMachineCallBacks and ProposalExecuteInterface , this will allow your new plugin to interact with the GenesisProtocol. Example with the TokenTrade plugin: contract TokenTrade is VotingMachineCallbacks, ProposalExecuteInterface { ... } In order to initialize the governance in the new plugin, you will need to initialize it, for that, you have to create an initialize method, like this: function initialize( Avatar _avatar, IntVoteInterface _votingMachine, uint256[11] calldata _votingParams, address _voteOnBehalf, bytes32 _voteParamsHash ) external { super._initializeGovernance(_avatar, _votingMachine, _voteParamsHash, _votingParams, _voteOnBehalf); } As you can see, you must pass five parameters, which are: - _avatar: The avatar (DAO) this plugin referring to. - _votingMachine: The voting machine address - _votingParams: GenesisProtocol parameters - valid only if _voteParamsHash is zero - _voteOnBehalf: GenesisProtocol parameter - valid only if _voteParamsHash is zero - _voteParamsHash: Voting machine parameters. Beside of these parameters, you can pass as many as you want; in case you want to store any useful information in a contract's variable. Next, you will need to create a struct Proposal ; this will allow you to store the information needed for the proposal (i.e: tokens to transfer/receive, REP to give, and any other use case you can imagine), note that this is the information the contract needs to have access to, things like title or description will be stored on IPFS (when we add our plugin at Subgraph level). Also, we will need a proposals mapping, to identify every proposal with a unique ID. Example with TokenTrade plugin: struct Proposal { address beneficiary; IERC20 sendToken; uint256 sendTokenAmount; IERC20 receiveToken; uint256 receiveTokenAmount; bool passed; bool decided; } mapping(bytes32=>Proposal) public proposals; Create a proposal${PLUGIN_NAME} , (i.e: proposalTokenTrade ). This function will create the proposal in the Voting Machine, by calling the votingMachine.propose(2, ...) function, the first argument of this function always needs to be 2 because it's the number of choices a proposal will have (Yes or No). Check the implementation of TokenTrade : function proposeTokenTrade( IERC20 _sendToken, uint256 _sendTokenAmount, IERC20 _receiveToken, uint256 _receiveTokenAmount, string memory _descriptionHash ) public returns(bytes32 proposalId) { require( address(_sendToken) != address(0) && address(_receiveToken) != address(0), \"Token address must not be null\" ); require(_sendTokenAmount > 0 && _receiveTokenAmount > 0, \"Token amount must be greater than 0\"); _sendToken.safeTransferFrom(msg.sender, address(this), _sendTokenAmount); proposalId = votingMachine.propose(2, voteParamsHash, msg.sender, address(avatar)); proposals[proposalId] = Proposal({ beneficiary: msg.sender, sendToken: _sendToken, sendTokenAmount: _sendTokenAmount, receiveToken: _receiveToken, receiveTokenAmount: _receiveTokenAmount, passed: false, decided: false }); proposalsBlockNumber[proposalId] = block.number; emit TokenTradeProposed( address(avatar), proposalId, _descriptionHash, msg.sender, _sendToken, _sendTokenAmount, _receiveToken, _receiveTokenAmount ); } In order to execute the proposal once it has passed, you need to implement an executeProposal method like this: function executeProposal(bytes32 _proposalId, int256 _decision) external onlyVotingMachine(_proposalId) override returns(bool) { ... } In this you will define what happens once the proposal has been approved or rejected, based on the _decision parameter. At last, you will need to implement tests for this contract.","title":"Arc"},{"location":"tutorials/register-a-plugin/arc/#create-a-plugin-on-arc","text":"As we said before, plugins are the DAO's actions, and if you want your DAO (or any DAO) to have a new action you can do it. First of all, you will need to add your new plugin in Arc. This means that you will need to fork the Arc repository , write your custom plugin, and create a PR to the daostack's repository","title":"Create a plugin on Arc"},{"location":"tutorials/register-a-plugin/arc/#writing-the-contracts","text":"Let's use as example the TrokenTrade plugin, to show how you should add your custom plugin: You need to create it in the folder schemes . Your contract will need to inherit from VotingMachineCallBacks and ProposalExecuteInterface , this will allow your new plugin to interact with the GenesisProtocol. Example with the TokenTrade plugin: contract TokenTrade is VotingMachineCallbacks, ProposalExecuteInterface { ... } In order to initialize the governance in the new plugin, you will need to initialize it, for that, you have to create an initialize method, like this: function initialize( Avatar _avatar, IntVoteInterface _votingMachine, uint256[11] calldata _votingParams, address _voteOnBehalf, bytes32 _voteParamsHash ) external { super._initializeGovernance(_avatar, _votingMachine, _voteParamsHash, _votingParams, _voteOnBehalf); } As you can see, you must pass five parameters, which are: - _avatar: The avatar (DAO) this plugin referring to. - _votingMachine: The voting machine address - _votingParams: GenesisProtocol parameters - valid only if _voteParamsHash is zero - _voteOnBehalf: GenesisProtocol parameter - valid only if _voteParamsHash is zero - _voteParamsHash: Voting machine parameters. Beside of these parameters, you can pass as many as you want; in case you want to store any useful information in a contract's variable. Next, you will need to create a struct Proposal ; this will allow you to store the information needed for the proposal (i.e: tokens to transfer/receive, REP to give, and any other use case you can imagine), note that this is the information the contract needs to have access to, things like title or description will be stored on IPFS (when we add our plugin at Subgraph level). Also, we will need a proposals mapping, to identify every proposal with a unique ID. Example with TokenTrade plugin: struct Proposal { address beneficiary; IERC20 sendToken; uint256 sendTokenAmount; IERC20 receiveToken; uint256 receiveTokenAmount; bool passed; bool decided; } mapping(bytes32=>Proposal) public proposals; Create a proposal${PLUGIN_NAME} , (i.e: proposalTokenTrade ). This function will create the proposal in the Voting Machine, by calling the votingMachine.propose(2, ...) function, the first argument of this function always needs to be 2 because it's the number of choices a proposal will have (Yes or No). Check the implementation of TokenTrade : function proposeTokenTrade( IERC20 _sendToken, uint256 _sendTokenAmount, IERC20 _receiveToken, uint256 _receiveTokenAmount, string memory _descriptionHash ) public returns(bytes32 proposalId) { require( address(_sendToken) != address(0) && address(_receiveToken) != address(0), \"Token address must not be null\" ); require(_sendTokenAmount > 0 && _receiveTokenAmount > 0, \"Token amount must be greater than 0\"); _sendToken.safeTransferFrom(msg.sender, address(this), _sendTokenAmount); proposalId = votingMachine.propose(2, voteParamsHash, msg.sender, address(avatar)); proposals[proposalId] = Proposal({ beneficiary: msg.sender, sendToken: _sendToken, sendTokenAmount: _sendTokenAmount, receiveToken: _receiveToken, receiveTokenAmount: _receiveTokenAmount, passed: false, decided: false }); proposalsBlockNumber[proposalId] = block.number; emit TokenTradeProposed( address(avatar), proposalId, _descriptionHash, msg.sender, _sendToken, _sendTokenAmount, _receiveToken, _receiveTokenAmount ); } In order to execute the proposal once it has passed, you need to implement an executeProposal method like this: function executeProposal(bytes32 _proposalId, int256 _decision) external onlyVotingMachine(_proposalId) override returns(bool) { ... } In this you will define what happens once the proposal has been approved or rejected, based on the _decision parameter. At last, you will need to implement tests for this contract.","title":"Writing the contracts"},{"location":"tutorials/register-a-plugin/arcjs/","text":"Registering a Plugin in Arc.js Creating the folder structure To register a new plugin, add a folder in the src/plugins folder, with the name of the plugin to register and create 3 files: proposal.ts plugin.ts index.ts The index file is always the same: export * from './plugin' export * from './proposal' The Plugin class definition will live in the plugin.ts file and the Proposal class definition will live in the proposal.ts file. Creating the Plugin class Interfaces The first step is to create 3 necessary interfaces: Plugin State : it describes the plugin state and must extend IPluginState interface. Typically it just adds the pluginParams field. Example with the TokenTrade plugin: export interface ITokenTradeState extends IPluginState { pluginParams: { votingMachine: Address voteParams: IGenesisProtocolParams } } Proposal Creation Options : it describes the arguments to pass to the proposal creation method. Must extend the IProposalBaseCreateOptions . Base options like dao address are already declared in the IProposalBaseCreateOptions interface. Example with the TokenTrade plugin: export interface IProposalCreateOptionsTokenTrade extends IProposalBaseCreateOptions { sendTokenAddress: Address, sendTokenAmount: number, receiveTokenAddress: Address, receiveTokenAmount: number, descriptionHash: string } Initialize Parameters : it describes the parameters to pass to the initialize contract method. Example with the TokenTrade plugin: export interface IInitParamsTT { daoId: string votingMachine: string votingParams: number[] voteOnBehalf: string voteParamsHash: string } Class definition If the plugin can create proposals, it must extend the ProposalPlugin class, if it can't, then it must extend the Plugin class. For this example, we will be using the TokenTrade plugin. The next step is to declare the class and make it extend ProposalPlugin , passing the 3 interfaces created in the previous section as type parameters: export class TokenTrade extends ProposalPlugin< ITokenTradeState, ITokenTradeProposalState, IProposalCreateOptionsTokenTrade> {... } Item Map Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState The goal of this method is to map the item object received by a query to an object of its interface. Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. Should return null if it did not return results: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState | null { if (!item) { return null } if (!item.tokenTradeParams) { throw new Error(`Plugin ${queriedId ? `with id '${queriedId}'` : ''}wrongly instantiated as TokenTrade Plugin`) } const baseState = Plugin.itemMapToBaseState(context, item) const tokenTradeParams = { voteParams: mapGenesisProtocolParams(item.tokenTradeParams.voteParams), votingMachine: item.tokenTradeParams.votingMachine } return { ...baseState, pluginParams: tokenTradeParams } } Initialize Params Mapper Next, implement the initializeParamsMap method, which follows the signature: public static initializeParamsMap(initParams: IInitParamsTT) It takes an object with the plugin's initialize parameters and returns an array with the parameters organized in the correct order to be passed to its contract, through the PluginManager : public static initializeParamsMap(initParams: IInitParamsTT) { Object.keys(initParams).forEach((key) => { if (initParams[key] === undefined) { throw new Error(`TokenTrade's initialize parameter '${key}' cannot be undefined`) } }) return [ initParams.daoId, initParams.votingMachine, initParams.votingParams, initParams.voteOnBehalf, initParams.voteParamsHash ] } Fragment Declare the public static fragment getter method and fragmentField private static property: private static fragmentField: { name: string, fragment: DocumentNode } | undefined public static get fragment() { if (!this.fragmentField) { this.fragmentField = { name: 'TokenTradeParams', fragment: gql` fragment TokenTradeParams on ControllerScheme { tokenTradeParams { id votingMachine voteParams { id queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } }` } } return this.fragmentField } Its objective is to include this plugin's specific fields in the general plugin search query. The name used for the actual GraphQL fragment definition must match the name property of the fragmentField property, in this case they both are: 'TokenTradeParams'. Typically the fragment starts with the name of the plugin, camel-cased and followed by 'Params', in this case it is 'tokenTradeParams' Create Proposal Next, implement the createProposalTransactionMap and createProposalErrorHandler , that always follow the same pattern: public createProposalTransactionMap(): transactionResultHandler<any> { return async (receipt: ITransactionReceipt) => { const args = getEventArgs(receipt, 'TokenTradeProposed', 'TokenTrade.createProposal') const proposalId = args[1] return new TokenTradeProposal(this.context, proposalId) } } public createProposalErrorHandler(options: IProposalCreateOptionsTokenTrade): transactionErrorHandler { return async (err) => { throw err } } You would only need to change the name of the event emitted by the contract on proposal creation, and the create proposal method, as shown above. Lastly, implement the createProposalTransaction method. This method has validation logic for each of the proposal creation options, saves the description hash to IPFS if there is none created beforehand and returns an object that contains the plugin's contract address, the name of the contract method to create a proposal and the arguments for it, organized in an array: public async createProposalTransaction(options: IProposalCreateOptionsTokenTrade): Promise<ITransaction> { if (options.plugin === undefined) { throw new Error(`Missing argument \"plugin\" for TokenTrade in Proposal.create()`) } if (!options.receiveTokenAddress) { throw new Error(`Missing argument \"receiveTokenAddress\" for TokenTrade in Proposal.create()`) } if (!options.sendTokenAddress) { throw new Error(`Missing argument \"sendTokenAddress\" for TokenTrade in Proposal.create()`) } if (options.receiveTokenAmount <= 0) { throw new Error(`Argument \"receiveTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (options.sendTokenAmount <= 0) { throw new Error(`Argument \"sendTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (!options.descriptionHash) { options.descriptionHash = await this.context.saveIPFSData(options) } const { address: pluginAddress } = await this.fetchState() await this.context.approveTokens(options.sendTokenAddress, pluginAddress, new BN(options.sendTokenAmount)).send() return { contract: this.context.getContract(pluginAddress), method: 'proposeTokenTrade', args: [ options.sendTokenAddress, options.sendTokenAmount, options.receiveTokenAddress, options.receiveTokenAmount, options.descriptionHash ] } } IMPORTANT NOTE: all other Arc.js entities or classes. used in this class must be imported from the src/index file : import { Address, Arc, getEventArgs, IGenesisProtocolParams, IPluginState, IProposalBaseCreateOptions, ITransaction, ITransactionReceipt, mapGenesisProtocolParams, Plugin, ProposalPlugin, transactionErrorHandler, transactionResultHandler } from '../../index' Registering the Plugin class The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. The Init Params interface must also be imported an mapped into the InitParams object in this file. export const ProposalPlugins = { FundingRequest, Join, GenericScheme: GenericPlugin, SchemeRegistrar: PluginRegistrarPlugin, ContributionReward: ContributionRewardPlugin, TokenTrade, Unknown: UnknownPlugin ... } export const Plugins = { ...ProposalPlugins, ReputationFromToken: ReputationFromTokenPlugin, Unknown: UnknownPlugin } export interface IInitParams { GenericScheme: IInitParamsGS, ContributionReward: IInitParamsCR, Competition: IInitParamsCompetition, ... } export type ProposalCreateOptions = IProposalCreateOptionsCRExt | IProposalCreateOptionsGS | IProposalCreateOptionsSR | ... Creating the Proposal class The Proposal class definition is, in essence, almost the same as the Plugin class definition, with some differences: The only interface that needs to be declared prior to the class creation is the Proposal State interface, which must always extend the IProposalState interface. An example would be: export interface ITokenTradeProposalState extends IProposalState { dao: IEntityRef<DAO> beneficiary: Address sendTokenAddress: Address sendTokenAmount: number receiveTokenAddress: Address receiveTokenAmount: number executed: boolean redeemed: boolean } The proposal class to be created needs to extend the abstract Proposal class, which takes the interface mentioned above as a type parameter: export class TokenTradeProposal extends Proposal<ITokenTradeProposalState> { ... } The state method must be implemented. It always follows the same implementation. You only need to change the Observable 's type parameter with the proper Proposal State interface: public state(apolloQueryOptions: IApolloQueryOptions): Observable<ITokenTradeProposalState> { const query = gql`query ProposalState { proposal(id: \"${this.id}\") { ...ProposalFields votes { id } stakes { id } } } ${Proposal.baseFragment} ${Plugin.baseFragment} ` const result = this.context.getObservableObject( this.context, query, TokenTradeProposal.itemMap, this.id, apolloQueryOptions ) as Observable<ITokenTradeProposalState> return result } The redeem method must be implemented Registering the Proposal Class The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Proposals object, mapped to its subgraph name: export const Proposals = { GenericScheme: GenericPluginProposal, ContributionReward: ContributionRewardProposal, Competition: CompetitionProposal, ContributionRewardExt: ContributionRewardExtProposal, FundingRequest: FundingRequestProposal, TokenTrade: TokenTradeProposal, Join: JoinProposal, SchemeRegistrar: PluginRegistrarProposal, SchemeRegistrarAdd: PluginRegistrarProposal, SchemeRegistrarRemove: PluginRegistrarProposal, SchemeFactory: PluginManagerProposal, Unknown: UnknownProposal } Exporting Plugin and Proposal classes The folder containing the plugin and proposal classes that were just implemented must be exported in the src/index file: export * from './entity' export * from './plugins/plugin' export * from './plugins/proposal' export * from './plugins/proposalPlugin' export * from './plugins/contributionReward' export * from './plugins/contributionRewardExt' export * from './plugins/tokenTrade' ...","title":"Arc.js"},{"location":"tutorials/register-a-plugin/arcjs/#registering-a-plugin-in-arcjs","text":"","title":"Registering a Plugin in Arc.js"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-folder-structure","text":"To register a new plugin, add a folder in the src/plugins folder, with the name of the plugin to register and create 3 files: proposal.ts plugin.ts index.ts The index file is always the same: export * from './plugin' export * from './proposal' The Plugin class definition will live in the plugin.ts file and the Proposal class definition will live in the proposal.ts file.","title":"Creating the folder structure"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-plugin-class","text":"","title":"Creating the Plugin class"},{"location":"tutorials/register-a-plugin/arcjs/#interfaces","text":"The first step is to create 3 necessary interfaces: Plugin State : it describes the plugin state and must extend IPluginState interface. Typically it just adds the pluginParams field. Example with the TokenTrade plugin: export interface ITokenTradeState extends IPluginState { pluginParams: { votingMachine: Address voteParams: IGenesisProtocolParams } } Proposal Creation Options : it describes the arguments to pass to the proposal creation method. Must extend the IProposalBaseCreateOptions . Base options like dao address are already declared in the IProposalBaseCreateOptions interface. Example with the TokenTrade plugin: export interface IProposalCreateOptionsTokenTrade extends IProposalBaseCreateOptions { sendTokenAddress: Address, sendTokenAmount: number, receiveTokenAddress: Address, receiveTokenAmount: number, descriptionHash: string } Initialize Parameters : it describes the parameters to pass to the initialize contract method. Example with the TokenTrade plugin: export interface IInitParamsTT { daoId: string votingMachine: string votingParams: number[] voteOnBehalf: string voteParamsHash: string }","title":"Interfaces"},{"location":"tutorials/register-a-plugin/arcjs/#class-definition","text":"If the plugin can create proposals, it must extend the ProposalPlugin class, if it can't, then it must extend the Plugin class. For this example, we will be using the TokenTrade plugin. The next step is to declare the class and make it extend ProposalPlugin , passing the 3 interfaces created in the previous section as type parameters: export class TokenTrade extends ProposalPlugin< ITokenTradeState, ITokenTradeProposalState, IProposalCreateOptionsTokenTrade> {... }","title":"Class definition"},{"location":"tutorials/register-a-plugin/arcjs/#item-map","text":"Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState The goal of this method is to map the item object received by a query to an object of its interface. Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. Should return null if it did not return results: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState | null { if (!item) { return null } if (!item.tokenTradeParams) { throw new Error(`Plugin ${queriedId ? `with id '${queriedId}'` : ''}wrongly instantiated as TokenTrade Plugin`) } const baseState = Plugin.itemMapToBaseState(context, item) const tokenTradeParams = { voteParams: mapGenesisProtocolParams(item.tokenTradeParams.voteParams), votingMachine: item.tokenTradeParams.votingMachine } return { ...baseState, pluginParams: tokenTradeParams } }","title":"Item Map"},{"location":"tutorials/register-a-plugin/arcjs/#initialize-params-mapper","text":"Next, implement the initializeParamsMap method, which follows the signature: public static initializeParamsMap(initParams: IInitParamsTT) It takes an object with the plugin's initialize parameters and returns an array with the parameters organized in the correct order to be passed to its contract, through the PluginManager : public static initializeParamsMap(initParams: IInitParamsTT) { Object.keys(initParams).forEach((key) => { if (initParams[key] === undefined) { throw new Error(`TokenTrade's initialize parameter '${key}' cannot be undefined`) } }) return [ initParams.daoId, initParams.votingMachine, initParams.votingParams, initParams.voteOnBehalf, initParams.voteParamsHash ] }","title":"Initialize Params Mapper"},{"location":"tutorials/register-a-plugin/arcjs/#fragment","text":"Declare the public static fragment getter method and fragmentField private static property: private static fragmentField: { name: string, fragment: DocumentNode } | undefined public static get fragment() { if (!this.fragmentField) { this.fragmentField = { name: 'TokenTradeParams', fragment: gql` fragment TokenTradeParams on ControllerScheme { tokenTradeParams { id votingMachine voteParams { id queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } }` } } return this.fragmentField } Its objective is to include this plugin's specific fields in the general plugin search query. The name used for the actual GraphQL fragment definition must match the name property of the fragmentField property, in this case they both are: 'TokenTradeParams'. Typically the fragment starts with the name of the plugin, camel-cased and followed by 'Params', in this case it is 'tokenTradeParams'","title":"Fragment"},{"location":"tutorials/register-a-plugin/arcjs/#create-proposal","text":"Next, implement the createProposalTransactionMap and createProposalErrorHandler , that always follow the same pattern: public createProposalTransactionMap(): transactionResultHandler<any> { return async (receipt: ITransactionReceipt) => { const args = getEventArgs(receipt, 'TokenTradeProposed', 'TokenTrade.createProposal') const proposalId = args[1] return new TokenTradeProposal(this.context, proposalId) } } public createProposalErrorHandler(options: IProposalCreateOptionsTokenTrade): transactionErrorHandler { return async (err) => { throw err } } You would only need to change the name of the event emitted by the contract on proposal creation, and the create proposal method, as shown above. Lastly, implement the createProposalTransaction method. This method has validation logic for each of the proposal creation options, saves the description hash to IPFS if there is none created beforehand and returns an object that contains the plugin's contract address, the name of the contract method to create a proposal and the arguments for it, organized in an array: public async createProposalTransaction(options: IProposalCreateOptionsTokenTrade): Promise<ITransaction> { if (options.plugin === undefined) { throw new Error(`Missing argument \"plugin\" for TokenTrade in Proposal.create()`) } if (!options.receiveTokenAddress) { throw new Error(`Missing argument \"receiveTokenAddress\" for TokenTrade in Proposal.create()`) } if (!options.sendTokenAddress) { throw new Error(`Missing argument \"sendTokenAddress\" for TokenTrade in Proposal.create()`) } if (options.receiveTokenAmount <= 0) { throw new Error(`Argument \"receiveTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (options.sendTokenAmount <= 0) { throw new Error(`Argument \"sendTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (!options.descriptionHash) { options.descriptionHash = await this.context.saveIPFSData(options) } const { address: pluginAddress } = await this.fetchState() await this.context.approveTokens(options.sendTokenAddress, pluginAddress, new BN(options.sendTokenAmount)).send() return { contract: this.context.getContract(pluginAddress), method: 'proposeTokenTrade', args: [ options.sendTokenAddress, options.sendTokenAmount, options.receiveTokenAddress, options.receiveTokenAmount, options.descriptionHash ] } } IMPORTANT NOTE: all other Arc.js entities or classes. used in this class must be imported from the src/index file : import { Address, Arc, getEventArgs, IGenesisProtocolParams, IPluginState, IProposalBaseCreateOptions, ITransaction, ITransactionReceipt, mapGenesisProtocolParams, Plugin, ProposalPlugin, transactionErrorHandler, transactionResultHandler } from '../../index'","title":"Create Proposal"},{"location":"tutorials/register-a-plugin/arcjs/#registering-the-plugin-class","text":"The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. The Init Params interface must also be imported an mapped into the InitParams object in this file. export const ProposalPlugins = { FundingRequest, Join, GenericScheme: GenericPlugin, SchemeRegistrar: PluginRegistrarPlugin, ContributionReward: ContributionRewardPlugin, TokenTrade, Unknown: UnknownPlugin ... } export const Plugins = { ...ProposalPlugins, ReputationFromToken: ReputationFromTokenPlugin, Unknown: UnknownPlugin } export interface IInitParams { GenericScheme: IInitParamsGS, ContributionReward: IInitParamsCR, Competition: IInitParamsCompetition, ... } export type ProposalCreateOptions = IProposalCreateOptionsCRExt | IProposalCreateOptionsGS | IProposalCreateOptionsSR | ...","title":"Registering the Plugin class"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-proposal-class","text":"The Proposal class definition is, in essence, almost the same as the Plugin class definition, with some differences: The only interface that needs to be declared prior to the class creation is the Proposal State interface, which must always extend the IProposalState interface. An example would be: export interface ITokenTradeProposalState extends IProposalState { dao: IEntityRef<DAO> beneficiary: Address sendTokenAddress: Address sendTokenAmount: number receiveTokenAddress: Address receiveTokenAmount: number executed: boolean redeemed: boolean } The proposal class to be created needs to extend the abstract Proposal class, which takes the interface mentioned above as a type parameter: export class TokenTradeProposal extends Proposal<ITokenTradeProposalState> { ... } The state method must be implemented. It always follows the same implementation. You only need to change the Observable 's type parameter with the proper Proposal State interface: public state(apolloQueryOptions: IApolloQueryOptions): Observable<ITokenTradeProposalState> { const query = gql`query ProposalState { proposal(id: \"${this.id}\") { ...ProposalFields votes { id } stakes { id } } } ${Proposal.baseFragment} ${Plugin.baseFragment} ` const result = this.context.getObservableObject( this.context, query, TokenTradeProposal.itemMap, this.id, apolloQueryOptions ) as Observable<ITokenTradeProposalState> return result } The redeem method must be implemented","title":"Creating the Proposal class"},{"location":"tutorials/register-a-plugin/arcjs/#registering-the-proposal-class","text":"The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Proposals object, mapped to its subgraph name: export const Proposals = { GenericScheme: GenericPluginProposal, ContributionReward: ContributionRewardProposal, Competition: CompetitionProposal, ContributionRewardExt: ContributionRewardExtProposal, FundingRequest: FundingRequestProposal, TokenTrade: TokenTradeProposal, Join: JoinProposal, SchemeRegistrar: PluginRegistrarProposal, SchemeRegistrarAdd: PluginRegistrarProposal, SchemeRegistrarRemove: PluginRegistrarProposal, SchemeFactory: PluginManagerProposal, Unknown: UnknownProposal }","title":"Registering the Proposal Class"},{"location":"tutorials/register-a-plugin/arcjs/#exporting-plugin-and-proposal-classes","text":"The folder containing the plugin and proposal classes that were just implemented must be exported in the src/index file: export * from './entity' export * from './plugins/plugin' export * from './plugins/proposal' export * from './plugins/proposalPlugin' export * from './plugins/contributionReward' export * from './plugins/contributionRewardExt' export * from './plugins/tokenTrade' ...","title":"Exporting Plugin and Proposal classes"},{"location":"tutorials/register-a-plugin/arcreact/","text":"","title":"Arcreact"},{"location":"tutorials/register-a-plugin/intro/","text":"","title":"Intro"},{"location":"tutorials/register-a-plugin/migration/","text":"","title":"Migration"},{"location":"tutorials/register-a-plugin/subgraph/","text":"Add your plugin into daostack's subgraph Once your plugin contract has been written, we need to add it into the subgraph, this way we can store the data emitted from the events that has happened in your contract (i.e: A proposal has been created). First of all, you will need to create inside of the src/mappings directory a folder with your plugin name, then, you will need to create four files: src/mappings/ + Plugin Name + /mapping.ts - Definition of handlers when your new contract's plugin emit a new event. src/mappings/ + Plugin Name + /schema.graphql - GraphQL schema for that contract, normally here goes the Proposal schema. src/mappings/ + Plugin Name + /datasource.yaml - a yaml fragment with: a. abis - optional - list of contract names that are required by the mapping. b. entities - list of entities that are written by the the mapping. c. eventHandlers - map of solidity event signatures to event handlers in mapping code. test/integration/ + Plugin Name + .spec.ts - we will need to test our integration on the subgraph too You will need to add your plugin in ops/mappings.json in every network, like so: { \"name\": \"plugin name as appears in `abis/arcVersion` folder\", \"contractName\": \"plugin name as appears in migration.json file\", \"dao\": \"section label where plugin is defined in migration.json file (base/dao/test/organs)>\", \"mapping\": \"plugin name\", \"arcVersion\": \"plugin arc version\" } Now, you have to add the new Plugin proposals in the domain and the controller, the files are the following: src/mappings/Controller/datasource.yaml - Add your plugin name in the abis section src/mappings/Controller/schema.graphql - You will define your plugin parameters as an entity (a.k.a: the initializer parameters of your contract), and then add it into the entity ControllerScheme src/mappings/Controller/mapping.ts - Create a function that will save the parameters of initialization of the plugin once it has been created. You can check the example from TokenTrade : export function setTokenTradeParams( avatar: Address, scheme: Address, vmAddress: Address, vmParamsHash: Bytes, ): void { setGPParams(vmAddress, vmParamsHash, avatar); let controllerScheme = ControllerScheme.load( crypto.keccak256(concat(avatar, scheme)).toHex(), ); let tokenTradeParams = new TokenTradeParam(scheme.toHex()); tokenTradeParams.votingMachine = vmAddress; tokenTradeParams.voteParams = vmParamsHash.toHex(); tokenTradeParams.save(); if (controllerScheme != null) { controllerScheme.tokenTradeParams = tokenTradeParams.id; controllerScheme.save(); } } src/domain/gpqueue.ts - Inside of the create function, you will to add a validation to check if the new plugin has been added, if true, it will bind the plugin with the new address and will set up the voting machine and parameters, an example is the following, with TokenTrade : if (equalStrings(contractInfo.name, 'TokenTrade')) { let tokenTrade = TokenTrade.bind(scheme); gpAddress = tokenTrade.votingMachine(); let voteParams = tokenTrade.voteParamsHash(); if (!equalStrings(gpAddress.toHex(), addressZero)) { setTokenTradeParams(dao, scheme, gpAddress, voteParams); isGPQue = true; } src/domain/proposal.ts - Here is where we are going to save our proposal. For that, you will create a function called update + initial of your plugin + Proposal , the parameters of this functions will be: proposalId: Bytes, createdAt: BigInt, avatarAddress: Address, descriptionHash: string, schemeAddress: Address . Check the JoinAndQuit update proposal function (Based on this example, the only line you will need to change is proposal.joinAndQuit , with the name of your plugin): export function updateJQProposal( proposalId: Bytes, createdAt: BigInt, avatarAddress: Address, descriptionHash: string, schemeAddress: Address, ): void { let proposal = getProposal(proposalId.toHex()); proposal.dao = avatarAddress.toHex(); proposal.joinAndQuit = proposalId.toHex(); proposal.createdAt = createdAt; proposal.descriptionHash = descriptionHash; proposal.scheme = crypto.keccak256(concat(avatarAddress, schemeAddress)).toHex(); getProposalIPFSData(proposal); saveProposal(proposal); } src/domain/index.ts - You have to create a new function which is going to be called handleNew + Plugin name + Proposal , here you are going to call two functions, the first one is update + initial of your plugin + Proposal function that you previously created on last step and handleGPProposalPrivate . See the handleNewTokenTradeProposal method as example: export function handleNewTokenTradeProposal( avatar: Address, proposalId: Bytes, timestamp: BigInt, descriptionHash: string, eventAddress: Address, ): void { if (!daoModule.exists(avatar)) { return; } updateTTProposal( proposalId, timestamp, avatar, descriptionHash, eventAddress, ); handleGPProposalPrivate(proposalId.toHex()); } src/domain/schema.graphql - You will add your plugin proposal, i.e: tokenTrade: TokenTradeProposal , TokenTradeProposal has already been defined in the schema.graphql of your plugin","title":"Subgraph"},{"location":"tutorials/register-a-plugin/subgraph/#add-your-plugin-into-daostacks-subgraph","text":"Once your plugin contract has been written, we need to add it into the subgraph, this way we can store the data emitted from the events that has happened in your contract (i.e: A proposal has been created). First of all, you will need to create inside of the src/mappings directory a folder with your plugin name, then, you will need to create four files: src/mappings/ + Plugin Name + /mapping.ts - Definition of handlers when your new contract's plugin emit a new event. src/mappings/ + Plugin Name + /schema.graphql - GraphQL schema for that contract, normally here goes the Proposal schema. src/mappings/ + Plugin Name + /datasource.yaml - a yaml fragment with: a. abis - optional - list of contract names that are required by the mapping. b. entities - list of entities that are written by the the mapping. c. eventHandlers - map of solidity event signatures to event handlers in mapping code. test/integration/ + Plugin Name + .spec.ts - we will need to test our integration on the subgraph too You will need to add your plugin in ops/mappings.json in every network, like so: { \"name\": \"plugin name as appears in `abis/arcVersion` folder\", \"contractName\": \"plugin name as appears in migration.json file\", \"dao\": \"section label where plugin is defined in migration.json file (base/dao/test/organs)>\", \"mapping\": \"plugin name\", \"arcVersion\": \"plugin arc version\" } Now, you have to add the new Plugin proposals in the domain and the controller, the files are the following: src/mappings/Controller/datasource.yaml - Add your plugin name in the abis section src/mappings/Controller/schema.graphql - You will define your plugin parameters as an entity (a.k.a: the initializer parameters of your contract), and then add it into the entity ControllerScheme src/mappings/Controller/mapping.ts - Create a function that will save the parameters of initialization of the plugin once it has been created. You can check the example from TokenTrade : export function setTokenTradeParams( avatar: Address, scheme: Address, vmAddress: Address, vmParamsHash: Bytes, ): void { setGPParams(vmAddress, vmParamsHash, avatar); let controllerScheme = ControllerScheme.load( crypto.keccak256(concat(avatar, scheme)).toHex(), ); let tokenTradeParams = new TokenTradeParam(scheme.toHex()); tokenTradeParams.votingMachine = vmAddress; tokenTradeParams.voteParams = vmParamsHash.toHex(); tokenTradeParams.save(); if (controllerScheme != null) { controllerScheme.tokenTradeParams = tokenTradeParams.id; controllerScheme.save(); } } src/domain/gpqueue.ts - Inside of the create function, you will to add a validation to check if the new plugin has been added, if true, it will bind the plugin with the new address and will set up the voting machine and parameters, an example is the following, with TokenTrade : if (equalStrings(contractInfo.name, 'TokenTrade')) { let tokenTrade = TokenTrade.bind(scheme); gpAddress = tokenTrade.votingMachine(); let voteParams = tokenTrade.voteParamsHash(); if (!equalStrings(gpAddress.toHex(), addressZero)) { setTokenTradeParams(dao, scheme, gpAddress, voteParams); isGPQue = true; } src/domain/proposal.ts - Here is where we are going to save our proposal. For that, you will create a function called update + initial of your plugin + Proposal , the parameters of this functions will be: proposalId: Bytes, createdAt: BigInt, avatarAddress: Address, descriptionHash: string, schemeAddress: Address . Check the JoinAndQuit update proposal function (Based on this example, the only line you will need to change is proposal.joinAndQuit , with the name of your plugin): export function updateJQProposal( proposalId: Bytes, createdAt: BigInt, avatarAddress: Address, descriptionHash: string, schemeAddress: Address, ): void { let proposal = getProposal(proposalId.toHex()); proposal.dao = avatarAddress.toHex(); proposal.joinAndQuit = proposalId.toHex(); proposal.createdAt = createdAt; proposal.descriptionHash = descriptionHash; proposal.scheme = crypto.keccak256(concat(avatarAddress, schemeAddress)).toHex(); getProposalIPFSData(proposal); saveProposal(proposal); } src/domain/index.ts - You have to create a new function which is going to be called handleNew + Plugin name + Proposal , here you are going to call two functions, the first one is update + initial of your plugin + Proposal function that you previously created on last step and handleGPProposalPrivate . See the handleNewTokenTradeProposal method as example: export function handleNewTokenTradeProposal( avatar: Address, proposalId: Bytes, timestamp: BigInt, descriptionHash: string, eventAddress: Address, ): void { if (!daoModule.exists(avatar)) { return; } updateTTProposal( proposalId, timestamp, avatar, descriptionHash, eventAddress, ); handleGPProposalPrivate(proposalId.toHex()); } src/domain/schema.graphql - You will add your plugin proposal, i.e: tokenTrade: TokenTradeProposal , TokenTradeProposal has already been defined in the schema.graphql of your plugin","title":"Add your plugin into daostack's subgraph"},{"location":"tutorials/register-a-plugin/test-environment/","text":"Registering a Plugin in Test-Env 1. Adding the Plugin information to a test DAO To test the registered plugin, it must be added to the test environment. The environment used to test Alchemy and Arc.js. In order to do that, first choose one of the DAOs for testing that already exist in the test-env repo, which are just JSON files with configuration parameters: For the sake of this example, we will use the TestDAO , to register the TokenTrade Plugin. The \"Schemes\" key of the testdao-params.json file contains an array. In this array add a new object with the following structure: name : string with the plugin's name. In this case, it would be \"TokenTrade\". alias : string with the plugin's alias. In this case, it would be \"Token Trade\". permissions : string that represents the permissions hash for the plugin initialization. In this case it would be \"0x00000000\". params : array that contains the initialize parameters to be passed to the initialize method of the plugin's contract. In this case it would be [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] So the JSON file would look like this: { \"orgName\": \"DAO For Testing\", \"tokenName\": \"DAO For Testing Token\", \"tokenSymbol\": \"DxFT\", \"VotingMachinesParams\": [...], \"Schemes\": [ { \"name\": \"ContributionReward\", \"alias\": \"Funding And Voting Power\", \"permissions\": \"0x00000000\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] }, { \"name\": \"TokenTrade\", \"alias\": \"Token Trade\", \"permissions\": \"0x00000000\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] }, { \"name\": \"SchemeRegistrar\", \"alias\" : \"Plugin Manager\", \"permissions\": \"0x0000001F\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 1 }, { \"voteParams\": 1 } ] }, ... 2. Bumping the test-env version Next, go to the package.json file and change the package version: { \"name\": \"@daostack/test-env-experimental\", \"version\": \"4.0.20\", \"description\": \"Testing environment for DAOstack projects.\", \"main\": \"index.js\", ... } 3. Release the new test-env with the newly registered plugin Run the release.sh script file, that exists at the repository's root folder. This will output some logs to the console and prompt for npm authentication to publish the new package. This script will release a new version of the 3 test-env docker images and a new version of the test-env npm package. 4. Using the new test-env in Alchemy/Arc.js In Alchemy/Arc.js codebase, change the test-env image versions in the docker-compose.yml file, so that they match the resulting version numbers from the previous step: ... ipfs: image: daostack/test-env-ipfs:3.0.38 ports: - 5001:5001 postgres: image: daostack/test-env-postgres:3.0.38 ports: - 9432:5432 environment: POSTGRES_PASSWORD: 'letmein' ganache: image: daostack/test-env-ganache:3.0.38 ports: - 8545:8545","title":"Test environment"},{"location":"tutorials/register-a-plugin/test-environment/#registering-a-plugin-in-test-env","text":"","title":"Registering a Plugin in Test-Env"},{"location":"tutorials/register-a-plugin/test-environment/#1-adding-the-plugin-information-to-a-test-dao","text":"To test the registered plugin, it must be added to the test environment. The environment used to test Alchemy and Arc.js. In order to do that, first choose one of the DAOs for testing that already exist in the test-env repo, which are just JSON files with configuration parameters: For the sake of this example, we will use the TestDAO , to register the TokenTrade Plugin. The \"Schemes\" key of the testdao-params.json file contains an array. In this array add a new object with the following structure: name : string with the plugin's name. In this case, it would be \"TokenTrade\". alias : string with the plugin's alias. In this case, it would be \"Token Trade\". permissions : string that represents the permissions hash for the plugin initialization. In this case it would be \"0x00000000\". params : array that contains the initialize parameters to be passed to the initialize method of the plugin's contract. In this case it would be [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] So the JSON file would look like this: { \"orgName\": \"DAO For Testing\", \"tokenName\": \"DAO For Testing Token\", \"tokenSymbol\": \"DxFT\", \"VotingMachinesParams\": [...], \"Schemes\": [ { \"name\": \"ContributionReward\", \"alias\": \"Funding And Voting Power\", \"permissions\": \"0x00000000\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] }, { \"name\": \"TokenTrade\", \"alias\": \"Token Trade\", \"permissions\": \"0x00000000\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 0 } ] }, { \"name\": \"SchemeRegistrar\", \"alias\" : \"Plugin Manager\", \"permissions\": \"0x0000001F\", \"params\": [ \"GenesisProtocolAddress\", { \"voteParams\": 1 }, { \"voteParams\": 1 } ] }, ...","title":"1. Adding the Plugin information to a test DAO"},{"location":"tutorials/register-a-plugin/test-environment/#2-bumping-the-test-env-version","text":"Next, go to the package.json file and change the package version: { \"name\": \"@daostack/test-env-experimental\", \"version\": \"4.0.20\", \"description\": \"Testing environment for DAOstack projects.\", \"main\": \"index.js\", ... }","title":"2. Bumping the test-env version"},{"location":"tutorials/register-a-plugin/test-environment/#3-release-the-new-test-env-with-the-newly-registered-plugin","text":"Run the release.sh script file, that exists at the repository's root folder. This will output some logs to the console and prompt for npm authentication to publish the new package. This script will release a new version of the 3 test-env docker images and a new version of the test-env npm package.","title":"3. Release the new test-env with the newly registered plugin"},{"location":"tutorials/register-a-plugin/test-environment/#4-using-the-new-test-env-in-alchemyarcjs","text":"In Alchemy/Arc.js codebase, change the test-env image versions in the docker-compose.yml file, so that they match the resulting version numbers from the previous step: ... ipfs: image: daostack/test-env-ipfs:3.0.38 ports: - 5001:5001 postgres: image: daostack/test-env-postgres:3.0.38 ports: - 9432:5432 environment: POSTGRES_PASSWORD: 'letmein' ganache: image: daostack/test-env-ganache:3.0.38 ports: - 8545:8545","title":"4. Using the new test-env in Alchemy/Arc.js"}]}