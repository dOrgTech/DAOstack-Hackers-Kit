{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAOstack DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"Home"},{"location":"#daostack","text":"DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"DAOstack"},{"location":"arc2-overview/","text":"Arc 2.0 What's new on the latest version of DAOstack architecture? Overview Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility. The changes None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"Arc 2.0"},{"location":"arc2-overview/#arc-20","text":"What's new on the latest version of DAOstack architecture?","title":"Arc 2.0"},{"location":"arc2-overview/#overview","text":"Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility.","title":"Overview"},{"location":"arc2-overview/#the-changes","text":"None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"The changes"},{"location":"plugins/funding-request/","text":"","title":"Funding Request"},{"location":"plugins/nft-manager/","text":"","title":"NFT Manager"},{"location":"plugins/token-trade/","text":"","title":"Token Trade"},{"location":"stack/alchemy/","text":"","title":"Alchemy"},{"location":"stack/arc/","text":"","title":"Arc"},{"location":"stack/arcjs/intro/","text":"","title":"Quick Example"},{"location":"stack/infra/holographic-consensus/","text":"Genesis Protocol Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article What is Staking? For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted. How does proposal state changes after staking? An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true. Staking Rewards Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost Caveats For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Holographic Consensus"},{"location":"stack/infra/holographic-consensus/#genesis-protocol","text":"Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article","title":"Genesis Protocol"},{"location":"stack/infra/holographic-consensus/#what-is-staking","text":"For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted.","title":"What is Staking?"},{"location":"stack/infra/holographic-consensus/#how-does-proposal-state-changes-after-staking","text":"An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true.","title":"How does proposal state changes after staking?"},{"location":"stack/infra/holographic-consensus/#staking-rewards","text":"Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost","title":"Staking Rewards"},{"location":"stack/infra/holographic-consensus/#caveats","text":"For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Caveats"},{"location":"stack/infra/intro/","text":"Infra Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Intro"},{"location":"stack/infra/intro/#infra","text":"Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Infra"},{"location":"stack/subgraph/entities/","text":"","title":"Entities"},{"location":"stack/subgraph/intro/","text":"","title":"Intro"},{"location":"stack/subgraph/queries/","text":"","title":"GraphQL queries"},{"location":"tutorials/arc-react/","text":"","title":"Arc.react"},{"location":"tutorials/create-a-dao/","text":"","title":"Create your own DAO"},{"location":"tutorials/register-a-plugin/","text":"","title":"Register a plugin"},{"location":"tutorials/test-environment/","text":"","title":"Test environment"},{"location":"tutorials/register-a-plugin/alchemy/","text":"","title":"Alchemy"},{"location":"tutorials/register-a-plugin/arc/","text":"","title":"Arc"},{"location":"tutorials/register-a-plugin/arcjs/","text":"","title":"Arc.js"},{"location":"tutorials/register-a-plugin/arcreact/","text":"","title":"Arcreact"},{"location":"tutorials/register-a-plugin/intro/","text":"","title":"Intro"},{"location":"tutorials/register-a-plugin/migration/","text":"","title":"Migration"},{"location":"tutorials/register-a-plugin/test-environment/","text":"","title":"Test environment"}]}