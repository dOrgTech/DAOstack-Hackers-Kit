{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAOstack DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"Home"},{"location":"#daostack","text":"DAOstack provides everything you need to start managing your community without a centralized authority. Launch your DAO - Decentralized Autonomous Organization using Adaptive, Modular and Upgradable governance structures powered by, DAOstack, a software stack for building Dapps (decentralized apps), DAOs (Decentralized Autonomous Organizations), and DAO tools. A dApp build with DAOstack DAOs consists of: - Public blockchain layer (Infra, Arc, Arc-Hive) which is the source of data - Caching layers (Subgraph) which allows fast access to the blockchain layer - Javascript library (Arc.js) for application layer integration.","title":"DAOstack"},{"location":"arc2-overview/","text":"Arc 2.0 What's new on the latest version of DAOstack architecture? Overview Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility. The changes None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"Arc 2.0"},{"location":"arc2-overview/#arc-20","text":"What's new on the latest version of DAOstack architecture?","title":"Arc 2.0"},{"location":"arc2-overview/#overview","text":"Arc 2.0 significantly eases DAO deployment, plugin management, and general gas costs, all this while increasing security. Its main objectives is to improve security, flexibility, user experience, and developer accessibility.","title":"Overview"},{"location":"arc2-overview/#the-changes","text":"None universal plugins All plugins are none universal which means a separate plugin instance per DAO. This reduces complexity at the contract level and increases security. All contracts are proxy upgradable contracts. Enable upgrades to DAO contracts implementations while maintaining addresses and storage. The DAO serves as the proxy admin of its own contracts. This increases security, UX, and enables upgradability. Arc.Hive ArcHive is an on-chain repository of all approved (Registered) DAOstack contract implementations. Contract/DAOs which have been registered / verified in the ArcHive will be automatically indexed and show up in Alchemy (higher layers of the stack) Plugins which would like to be added to the ArcHive need to be approved and verified by DAOstack. We aspire to have this managed by the community in the future. The ArcHive architecture increases security via a tool that validates contracts and implementation in a trust-minimized way. DAOFactory DAO deployment in a seamless process, in a single transacation DAO deployment cost is reduced by a factor of 10. Use ArcHive contracts to create a DAO DAO Factory DAOs will be indexed and will be shown in alchemy. DAO creation is made fast, Cheap and with far better UX. PluginFactory Simplified process of the \u201cPlugin Manager\u201d in updating / adding of plugins to the DAO. Plugin parameters are passed via the plugin add proposal. A new Plugin instance is created and deployed upon execution. GenesisProtocol parameters are set upon plugin Init, no need to pre-deploy governance parameters Easy and friendly UX Tx Cost Optimization was done to genesis protocol and plugins structure to reduce gas required for proposing/voting/staking. Subgraph auto indexing All Arc.Hive plugins/DAOs are automatically indexed by subgraph (no need to manually index). Misc NFT management plugin - send/mint/list Arc.react - enable easy custom react ui components on top of subgraph and arc.js JoinAndQuit and Funding Request Token Trade - Send and receive tokens from/to the organization. Key value on chain database Etherscan/blockscout contract verification upon DAO deployment. Full xDAI support with ERC20 token contract bridge.","title":"The changes"},{"location":"plugins/funding-request/","text":"","title":"Funding Request"},{"location":"plugins/nft-manager/","text":"","title":"NFT Manager"},{"location":"plugins/token-trade/","text":"","title":"Token Trade"},{"location":"stack/alchemy/","text":"","title":"Alchemy"},{"location":"stack/arc/","text":"Arc Arc is a solidity smart contract library for building DAOs, uses Infra to provide decentralized organizations with voting machines and voting rights management systems. Is the base layer of the DAO stack. It defines the basic building blocks and standard components that can be used to implement any DAO. DAOs built with Arc have a few basic contract components: Avatar : The DAO's \"account\". This contract represents the address of the DAO and holds its assets. Reputation : Voting in Arc is done mainly using Reputation. Reputation can be distributed and redistributed only by DAO decision, and it is generally given (via vote) to an agent according to their performance and contribution to a DAO. Token : Each DAO have its own token, which can be used in any way the DAO would like. Controller : Is the \"Access Control\" of the DAO, managing who can interact with which DAO functions and enforcing the DAO's constraints. Plugins : Are a DAO's \"actions\". Anything a DAO should act upon needs to be written and authorized by the controller as a plugin. Plugins might be used to help a DAO: propose and make investments, give reputation to agents, upgrade the DAO's contracts, register new plugins and constraints, etc. Global Constraints : Are limitations on a DAO's actions. When executing a plugin, the controller checks the constraints to see if the action violates them, and blocks the execution if it does. Some examples for constraints might be: the token supply can't be increased over 1M tokens, the organization won't use more than 60% of its funds at once, etc. It has been built from the ground up with these principles in mind: Scalable Decentralized Governance - Implements game theory & economic techniques (such as: monetization of attention, staking on proposal results, and more) that, even as the number of the participants gets very large, ensures high: Resilience - resistance to a disproportionate decision power in the hands of minorities. Bandwidth - decision making rate of the organization. Security - Is community audited and embodies the best security guidelines and is very well tested. Interoperability & Compositionality - Can integrate with any other ethereum based framework with ease. Organizations can interact with each other and form hierarchies and other complex structures. Modularity - Is built in a modular way allowing anyone to extend and expand the ecosystem to support new use-cases. General purpose - Provides a single unified simple model for building any DAO imaginable.","title":"Arc"},{"location":"stack/arc/#arc","text":"Arc is a solidity smart contract library for building DAOs, uses Infra to provide decentralized organizations with voting machines and voting rights management systems. Is the base layer of the DAO stack. It defines the basic building blocks and standard components that can be used to implement any DAO. DAOs built with Arc have a few basic contract components: Avatar : The DAO's \"account\". This contract represents the address of the DAO and holds its assets. Reputation : Voting in Arc is done mainly using Reputation. Reputation can be distributed and redistributed only by DAO decision, and it is generally given (via vote) to an agent according to their performance and contribution to a DAO. Token : Each DAO have its own token, which can be used in any way the DAO would like. Controller : Is the \"Access Control\" of the DAO, managing who can interact with which DAO functions and enforcing the DAO's constraints. Plugins : Are a DAO's \"actions\". Anything a DAO should act upon needs to be written and authorized by the controller as a plugin. Plugins might be used to help a DAO: propose and make investments, give reputation to agents, upgrade the DAO's contracts, register new plugins and constraints, etc. Global Constraints : Are limitations on a DAO's actions. When executing a plugin, the controller checks the constraints to see if the action violates them, and blocks the execution if it does. Some examples for constraints might be: the token supply can't be increased over 1M tokens, the organization won't use more than 60% of its funds at once, etc. It has been built from the ground up with these principles in mind: Scalable Decentralized Governance - Implements game theory & economic techniques (such as: monetization of attention, staking on proposal results, and more) that, even as the number of the participants gets very large, ensures high: Resilience - resistance to a disproportionate decision power in the hands of minorities. Bandwidth - decision making rate of the organization. Security - Is community audited and embodies the best security guidelines and is very well tested. Interoperability & Compositionality - Can integrate with any other ethereum based framework with ease. Organizations can interact with each other and form hierarchies and other complex structures. Modularity - Is built in a modular way allowing anyone to extend and expand the ecosystem to support new use-cases. General purpose - Provides a single unified simple model for building any DAO imaginable.","title":"Arc"},{"location":"stack/arcjs/development/","text":"Developing For development, it is useful to have local instances of Ganache (an ethereum node), IPFS (which is used to store data), an instance of The Graph with the DAOStack subgraph. The package is provided with convenient docker containers that provide a complete environment for testing and development: Get all services running: docker-compose up This command will build and start a graph instance, ganache, IPFS and postgresql. To run the tests, run: npm run test You may also want to run the (demo.js)[./documentation/demo.js] file for some concrete examples of the usage of the library: node documentation/demo.js After you are done, run: docker-compose down Adding an Entity The Event entity will be used as example in this section. To add an entity to the library, you must: Create an interface that defines the entity state. export interface IEventState { id: string dao: string proposal: string user: string type: string data: { [key: string]: any } timestamp: string } Create an interface that defines the possible options to query the entity. This interface must extend the ICommonQueryOptions interface. export interface IEventQueryOptions extends ICommonQueryOptions { where?: { id?: string; dao?: Address; proposal?: string; user?: Address; [key: string]: any; } } Create the entity class. This class must extend the Entity<TState> abstract class, where TState is the interface created in step 1. Implement the public static fragments field. Here you can define entity related GraphQL fragments to use in GraphQL queries. public static fragments = { EventFields: gql` fragment EventFields on Event { id dao { id } type data user proposal { id } timestamp } ` } Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): IEntityState The goal of this method is to map the item object received by a query to an object of its interface. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. public static itemMap(context: Arc, item: any, queriedId?: string): IEventState { if (!item) { throw Error(`Event ItemMap failed. ${queriedId ? `Could not find Event with id '${queriedId}'` : ''}`) } return { dao: item.dao.id, data: JSON.parse(item.data), id: item.id, proposal: item.proposal && item.proposal.id, timestamp: item.timestamp, type: item.type, user: item.user } } Implement the public static search method, which follows the signature: public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> It typically builds a search query using the GraphQL fragments defined in step 4. This method must return a call to context.getObservableList and its return type should be casted to Observable<Entity> , where entity is the Entity class where this method is being defined. public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> { const itemMap = (arc: Arc, item: any, queriedId?: string) => { const state = Event.itemMap(arc, item, queriedId) return new Event(arc, state) } const query = gql`query EventSearch { events ${createGraphQlQuery(options)} { ...EventFields } } ${Event.fragments.EventFields} ` return context.getObservableList(context, query, itemMap, options.where?.id, apolloQueryOptions) as Observable<Event[]> } Implement the public state method. This method queries the subgraph for the entity based on its ID, to retrieve its state. The method must return a this.context.getObservableObject call. public state(apolloQueryOptions: IApolloQueryOptions = {}): Observable<IEventState> { const query = gql` query EventState { event (id: \"${this.id}\") { ...EventFields } } ${Event.fragments.EventFields} ` return this.context.getObservableObject(this.context, query, Event.itemMap, this.id, apolloQueryOptions) } Export this class in the ./src/index.ts file, using export * from syntax. It is important to note all imports from this library must be imported from the ./src/index.ts file. Adding a Plugin Adding a plugin is similar to adding an entity, with the following differences: The interface that defines the Entity state must extend IPluginState interface. Typically it just adds the pluginParams field. export interface IGenericPluginState extends IPluginState { pluginParams: { votingMachine: Address contractToCall: Address voteParams: IGenesisProtocolParams } } Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. If the Plugin can create Proposals , then the added plugin must extend from abstract class ProposalPlugin<IPluginState, IProposalState, IProposalCreateOptions> IPluginState is the interface defined in the previous step. IProposalState is the interface that defines the state of the proposal that can be created by the plugin. IProposalCreateOptions is the interface that defines the options passed to create a proposal using the plugin. If the Plugin cannot create Proposals , then it must extend from the Plugin<IPluginState> abstract class. If the plugin has fields that should be queried in the Plugin 's class baseFragment query, then it must define a public static fragment field which has the following signature: public static fragment: { name: string, fragment: DocumentNode } name is the name of the GraphQL fragment. It must match the name used in the fragment definition. fragment is the actual GraphQL fragment. public static fragment = { name: 'GenericpluginParams', fragment: gql` fragment GenericpluginParams on ControllerScheme { genericSchemeParams { votingMachine contractToCall voteParams { queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } } ` } The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. Adding a Proposal Adding a Proposal follows similar rules to adding a Plugin , noting that created Proposal classes must be exported in the same way plugins are. Testing run a specific test: npm run test -- test/arc.spec.ts Or watch: npm run test -- --watch Commands npm run build : Generate bundles and typings, create docs npm run lint : Lints code npm run test : run all tests","title":"Developing"},{"location":"stack/arcjs/development/#developing","text":"For development, it is useful to have local instances of Ganache (an ethereum node), IPFS (which is used to store data), an instance of The Graph with the DAOStack subgraph. The package is provided with convenient docker containers that provide a complete environment for testing and development: Get all services running: docker-compose up This command will build and start a graph instance, ganache, IPFS and postgresql. To run the tests, run: npm run test You may also want to run the (demo.js)[./documentation/demo.js] file for some concrete examples of the usage of the library: node documentation/demo.js After you are done, run: docker-compose down","title":"Developing"},{"location":"stack/arcjs/development/#adding-an-entity","text":"The Event entity will be used as example in this section. To add an entity to the library, you must: Create an interface that defines the entity state. export interface IEventState { id: string dao: string proposal: string user: string type: string data: { [key: string]: any } timestamp: string } Create an interface that defines the possible options to query the entity. This interface must extend the ICommonQueryOptions interface. export interface IEventQueryOptions extends ICommonQueryOptions { where?: { id?: string; dao?: Address; proposal?: string; user?: Address; [key: string]: any; } } Create the entity class. This class must extend the Entity<TState> abstract class, where TState is the interface created in step 1. Implement the public static fragments field. Here you can define entity related GraphQL fragments to use in GraphQL queries. public static fragments = { EventFields: gql` fragment EventFields on Event { id dao { id } type data user proposal { id } timestamp } ` } Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): IEntityState The goal of this method is to map the item object received by a query to an object of its interface. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. public static itemMap(context: Arc, item: any, queriedId?: string): IEventState { if (!item) { throw Error(`Event ItemMap failed. ${queriedId ? `Could not find Event with id '${queriedId}'` : ''}`) } return { dao: item.dao.id, data: JSON.parse(item.data), id: item.id, proposal: item.proposal && item.proposal.id, timestamp: item.timestamp, type: item.type, user: item.user } } Implement the public static search method, which follows the signature: public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> It typically builds a search query using the GraphQL fragments defined in step 4. This method must return a call to context.getObservableList and its return type should be casted to Observable<Entity> , where entity is the Entity class where this method is being defined. public static search( context: Arc, options: IEventQueryOptions = {}, apolloQueryOptions: IApolloQueryOptions = {} ): Observable<Event[]> { const itemMap = (arc: Arc, item: any, queriedId?: string) => { const state = Event.itemMap(arc, item, queriedId) return new Event(arc, state) } const query = gql`query EventSearch { events ${createGraphQlQuery(options)} { ...EventFields } } ${Event.fragments.EventFields} ` return context.getObservableList(context, query, itemMap, options.where?.id, apolloQueryOptions) as Observable<Event[]> } Implement the public state method. This method queries the subgraph for the entity based on its ID, to retrieve its state. The method must return a this.context.getObservableObject call. public state(apolloQueryOptions: IApolloQueryOptions = {}): Observable<IEventState> { const query = gql` query EventState { event (id: \"${this.id}\") { ...EventFields } } ${Event.fragments.EventFields} ` return this.context.getObservableObject(this.context, query, Event.itemMap, this.id, apolloQueryOptions) } Export this class in the ./src/index.ts file, using export * from syntax. It is important to note all imports from this library must be imported from the ./src/index.ts file.","title":"Adding an Entity"},{"location":"stack/arcjs/development/#adding-a-plugin","text":"Adding a plugin is similar to adding an entity, with the following differences: The interface that defines the Entity state must extend IPluginState interface. Typically it just adds the pluginParams field. export interface IGenericPluginState extends IPluginState { pluginParams: { votingMachine: Address contractToCall: Address voteParams: IGenesisProtocolParams } } Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. If the Plugin can create Proposals , then the added plugin must extend from abstract class ProposalPlugin<IPluginState, IProposalState, IProposalCreateOptions> IPluginState is the interface defined in the previous step. IProposalState is the interface that defines the state of the proposal that can be created by the plugin. IProposalCreateOptions is the interface that defines the options passed to create a proposal using the plugin. If the Plugin cannot create Proposals , then it must extend from the Plugin<IPluginState> abstract class. If the plugin has fields that should be queried in the Plugin 's class baseFragment query, then it must define a public static fragment field which has the following signature: public static fragment: { name: string, fragment: DocumentNode } name is the name of the GraphQL fragment. It must match the name used in the fragment definition. fragment is the actual GraphQL fragment. public static fragment = { name: 'GenericpluginParams', fragment: gql` fragment GenericpluginParams on ControllerScheme { genericSchemeParams { votingMachine contractToCall voteParams { queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } } ` } The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file.","title":"Adding a Plugin"},{"location":"stack/arcjs/development/#adding-a-proposal","text":"Adding a Proposal follows similar rules to adding a Plugin , noting that created Proposal classes must be exported in the same way plugins are.","title":"Adding a Proposal"},{"location":"stack/arcjs/development/#testing","text":"run a specific test: npm run test -- test/arc.spec.ts Or watch: npm run test -- --watch","title":"Testing"},{"location":"stack/arcjs/development/#commands","text":"npm run build : Generate bundles and typings, create docs npm run lint : Lints code npm run test : run all tests","title":"Commands"},{"location":"stack/arcjs/intro/","text":"","title":"Quick Example"},{"location":"stack/infra/holographic-consensus/","text":"Genesis Protocol Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article What is Staking? For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted. How does proposal state changes after staking? An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true. Staking Rewards Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost Caveats For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Holographic Consensus"},{"location":"stack/infra/holographic-consensus/#genesis-protocol","text":"Genesis Protocol is an organization's voting machine implemented by DAOstack team. It leverages the Holographic Consensus mechanism for scaling the decentralized governance system. You can find details on design principals and high level overview here In this article we will go through some technical details of Genesis Protocol Each DAO can set the following Genesis Protocol parameters according to organization's need, while setting the scheme parameters: Activation time : The point (represented in Unix time) in time when psroposing and voting are activated. Boosted vote period limit : The length of time that voting is open for boosted proposals. Dao bounty cost : This is multiplied by the average downstake on boosted proposals to calculate how large the DAO\u2019s automatic downstake should be. Minimum dao bounty : The minimum amount of GEN a DAO will stake when automatically downstaking each proposal. Pre boosted vote period limit : The length of time that a proposal must maintain a confidence score higher than the boosting threshold to become eligible for boosting. Proposing rep reward : The amount of voting power given out as a reward for submitting a proposal that the DAO passes. Queued vote period limit : The length of time that voting is open for non-boosted proposals. Queued vote required percentage : The quorum required to decide a vote on a non-boosted proposal. Quiet ending period : The length of time a vote\u2019s potential result needs to stay the same in order to be confirmed as the official result. Threshold const : Controls how quickly the required confidence score for boosting goes up as the number of currently boosted proposals rises. Voters reputation loss ratio : The percentage of a voter\u2019s voting power they stand to lose if they vote against the DAO\u2019s eventual decision on a non-boosted proposal. For more details and story around each param refer this article","title":"Genesis Protocol"},{"location":"stack/infra/holographic-consensus/#what-is-staking","text":"For a proposal to pass with a relative majority, it must have sufficient stake in favor of the proposal. You can use your GEN tokens to stake in favor of or against the proposal. Once the stakes in favor of the proposal reaches the bar it is ready to be boosted.","title":"What is Staking?"},{"location":"stack/infra/holographic-consensus/#how-does-proposal-state-changes-after-staking","text":"An open proposal (i.e. with pending decision) can be in one of the following stages: Queued : All proposals when submitted are in queued state and by default have downstake > 0. This is decided by minimumDaoBounty parameter. The proposal requires absolute majority (i.e. > 50% vote) to pass in this state. PreBoosted : Once the stakes in favor of the proposal crosses the boosting bar it moves from queued to preboosted state. The boosting bar is decided by following genesis parameters and current dao state. stakes(For)/stakes(Against) > (thresholdConst)^(#aready-boosted-proposals) The proposal in this state is open for staking and can be moved back to queued state if the stake against is increases and the above equation becomes false. Boosted : Once the proposal has been in preboosted state for period set preBoostedVotePeriodLimit parameter, the proposal moves to boosted state. The proposal in this state requires relative majority to pass (i.e votes(For) > votes(Against)). The proposal in this state is open for voting but cannot be staked on. Thus, once a proposal is boosted it cannot be moved back to queued or preboosted state. The proposal stays in this state until boostedVotePeriodLimit elapse. QuietEndingPeriod : If the winning outcome of the proposal flips from 'pass' to 'fail' or vice-versa during the last period decided by quietEndingPeriod parameter, then the proposal voting get extended by quietEndingPeriod time and the proposal enters the quietEndingPeriod . The proposal's outcome must not change for the quietEndingPeriod amount of time for the decision to be made. Else the voting on proposal keeps getting increased by the quietEndingPeriod amount of time until the above condition is true.","title":"How does proposal state changes after staking?"},{"location":"stack/infra/holographic-consensus/#staking-rewards","text":"Following are the possible outcomes of a proposal: The proposal expires in queue without any decision: In this case all the stakes are returned to the respective staker. The proposal passes: Staker(stake(for) amount)*daoBounty/(total winning stake) The proposal fails: Loosing stake is lost","title":"Staking Rewards"},{"location":"stack/infra/holographic-consensus/#caveats","text":"For a given proposal one can stake multiple times from the same address. In such a case all the subsequent stakes must in align with previous stake's vote i.e. if staked in favor of the proposal earlier you must stake in favor of the proposal in subsequent stakes While you can stake against the proposal in pre-boosted state, the staking stops once the proposal is in boosted state.","title":"Caveats"},{"location":"stack/infra/intro/","text":"Infra Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Intro"},{"location":"stack/infra/intro/#infra","text":"Infra is a Solidity smart contract library containing the core building blocks of decentralized governance. Infra contracts can be integrated into any application regardless of its architecture. Infra has two main components: Voting Machines - A voting machine is a universal contract which can operate the voting process for any organization. Each voting machine follows its own predefined rules for the decision making and execution process. Rules for voting machines can be implemented for any voting process, from a simple protocol like an \"Absolute Vote\" (where 51% of the voting power should approve it in order for the decision to pass), or more sophisticated protocols like the Holographic Consensus voting protocol. Voting Rights Management - A voting rights management system determines how voting rights are distributed. Any voting rights management system must have \"balances\" which represents the voting power each participant holds. There are 2 main approaches for managing voting rights: token-based voting and reputation-based voting. The main technical difference between the two is that tokens are transferable (i.e. tradable) while reputation is non-transferable. Another big difference which may appear (depending on implementation) is that a token is a property which cannot be taken while reputation may be redistributed by the organization itself. For most cases, we reccomend using the reputation-based voting model, however, Infra allows any voting right management system to be built.","title":"Infra"},{"location":"stack/subgraph/entities/","text":"","title":"Entities"},{"location":"stack/subgraph/intro/","text":"","title":"Intro"},{"location":"stack/subgraph/queries/","text":"","title":"GraphQL queries"},{"location":"tutorials/arc-react/","text":"Arc.react Arc.react it's a react library that exposes arc.js functions and subgraph data in react components. Making it easier to develop on top of DAOstack, because it allows the developer to: Build DAOs faster, easier, and better: Enables easy react application deployment and integration, and significantly simplifies building of custom DAO UIs, interfaces, pages, and website native UI. Create a better flow for projects/DAOs looking to onboard streams of new users Take the DAOs where the audience already is, instead of forcing them to come to another app (i.e: Alchemy) Before going forward with how to use the library in your application, we recommend reading the architecture and examples docs so you have a preview of how the library works. Also, as this tutorial go, you can check the api documentation so you can see every component in depth. To add this library into your react app you need to install it first: npm i --save @daostack/arc.react As second step, you will need to connect Arc protocol to React with the Arc component. The Arc is similar to React's Context.Provider. It wraps your React app and places the client on the context, which enables you to access it from anywhere in your component tree. We suggest putting Arc somewhere high in your app, above any component from arc.react library, because, since it's the one that allows the app to connect to the Arc protocol, all components are dependent of it (If you are familiar with @apollo/client library, you can see it as if this is the ApolloProvider object, that wraps the entire application in it). You connect to the Arc protocol using and ArcConfig object like so (please check Protocol connection to get more information about it): import { Arc, ArcConfig } from \"@daostack/arc.react\"; <Arc config={new ArcConfig(\"rinkeby\")}>All other components go here</Arc>; And the last step to connecting your DAO into your app, you need to use the DAO component, passing the address of your DAO as a prop, like this: import { DAO } from \"@daostack/arc.react\"; <DAO address=\"0xMY_DAO\">Your app</DAO>; Now you are ready to code your react app that interacts with Arc protocol! At the end the application should look like this: import { Arc, ArcConfig, DAO } from \"@daostack/arc.react\"; const App = () => { const arcConfig = new ArcConfig(\"rinkeby\"); return ( <Arc config={arcConfig}> <DAO address=\"0xMY_DAO\">Here goes your app!</DAO> </Arc> ); }; Now you can see the members of your DAO: <Members> <Member.Data>{(data: MemberData) => <div>{data.address}</div>}</Member.Data> </Members> And the proposals: <Proposals> <Proposal.Data> <Proposal.Entity> {(data: ProposalData, entity: ProposalEntity) => ( <div> <h1>{data.title}</h1> <button onClick={() => entity.vote({...})}> Up Vote </button> <button onClick={() => entity.vote({...})}> Down Vote </button> </div> )} </Proposal.Entity> </Proposal.Data> </Proposals> And any other entity within the DAOstack protocol ! You can check the demo application built with arc.react on this repository: https://github.com/dOrgTech/arc.react-demo","title":"Arc.react"},{"location":"tutorials/arc-react/#arcreact","text":"Arc.react it's a react library that exposes arc.js functions and subgraph data in react components. Making it easier to develop on top of DAOstack, because it allows the developer to: Build DAOs faster, easier, and better: Enables easy react application deployment and integration, and significantly simplifies building of custom DAO UIs, interfaces, pages, and website native UI. Create a better flow for projects/DAOs looking to onboard streams of new users Take the DAOs where the audience already is, instead of forcing them to come to another app (i.e: Alchemy) Before going forward with how to use the library in your application, we recommend reading the architecture and examples docs so you have a preview of how the library works. Also, as this tutorial go, you can check the api documentation so you can see every component in depth. To add this library into your react app you need to install it first: npm i --save @daostack/arc.react As second step, you will need to connect Arc protocol to React with the Arc component. The Arc is similar to React's Context.Provider. It wraps your React app and places the client on the context, which enables you to access it from anywhere in your component tree. We suggest putting Arc somewhere high in your app, above any component from arc.react library, because, since it's the one that allows the app to connect to the Arc protocol, all components are dependent of it (If you are familiar with @apollo/client library, you can see it as if this is the ApolloProvider object, that wraps the entire application in it). You connect to the Arc protocol using and ArcConfig object like so (please check Protocol connection to get more information about it): import { Arc, ArcConfig } from \"@daostack/arc.react\"; <Arc config={new ArcConfig(\"rinkeby\")}>All other components go here</Arc>; And the last step to connecting your DAO into your app, you need to use the DAO component, passing the address of your DAO as a prop, like this: import { DAO } from \"@daostack/arc.react\"; <DAO address=\"0xMY_DAO\">Your app</DAO>; Now you are ready to code your react app that interacts with Arc protocol! At the end the application should look like this: import { Arc, ArcConfig, DAO } from \"@daostack/arc.react\"; const App = () => { const arcConfig = new ArcConfig(\"rinkeby\"); return ( <Arc config={arcConfig}> <DAO address=\"0xMY_DAO\">Here goes your app!</DAO> </Arc> ); }; Now you can see the members of your DAO: <Members> <Member.Data>{(data: MemberData) => <div>{data.address}</div>}</Member.Data> </Members> And the proposals: <Proposals> <Proposal.Data> <Proposal.Entity> {(data: ProposalData, entity: ProposalEntity) => ( <div> <h1>{data.title}</h1> <button onClick={() => entity.vote({...})}> Up Vote </button> <button onClick={() => entity.vote({...})}> Down Vote </button> </div> )} </Proposal.Entity> </Proposal.Data> </Proposals> And any other entity within the DAOstack protocol ! You can check the demo application built with arc.react on this repository: https://github.com/dOrgTech/arc.react-demo","title":"Arc.react"},{"location":"tutorials/create-a-dao/","text":"DAO creator DAOcreator is a tool that allows you to deploy your DAO in a super simple way. It has a UI which you can find in Alchemy dApp When you create a DAO, it create an instance of the multiple components defined in Arc Deploying a DAO with this tool consists of three steps which are: 1- Setting the DAO name and symbol 2- Configure proposals parameters 3- Define the members of your organization Let's go step by step and what every step does: Setting the DAO name and symbol In this section, you will set the DAO's name and the Token's symbol. Configure proposals parameters Here you will define the mechanics of the proposals, from here you can choose the amount of time allotted for votes to come to a close when it comes to making decisions. Choose \u201cSlow\u201d, \u201cMedium\u201d, or \u201cFast\u201d depending on how long you want the voting periods to be. If you\u2019d like to know how long each setting is, simply hover over the buttons to know how many days are given for each type of vote. Then you can choose to add three options, which are: Reward successful proposer: If the proposal passes, the proposer will get a certain amount of REP Reward correct voters and penalize incorrect voters: If the proposal is boosted, the stakers that did the bet for the winning result will get a certain amount of REP Auto-incentivize proposal curation: When a proposal is created, the organization will bet agaisnt the proposal If you are a experienced user in the stack the advanced configuration allows you to configure the voting mechanics as you desire. Please refer to Genesis Protocol documentation to know what the parameters are and what they do. Define the members Here you will be able to add the addresses of whichever members you would like to be a part of the DAO. You will be able to vote to add more members at a later date, but if you have their addresses now, it\u2019s best to get that done now. Each member will be identified by their eth address, so make sure each one is inserted correctly. Misc Export/Import config The DAOcreator allows you to import/export the entire configuration of your DAO. In case you already have your set up but want to send it to someone or wait for another address. You can get the migration-params.json file from the Export configuration button. Import members On the Add members section, there is a button at the top right, that allows you to import a CSV with the members. You can check how to create this CSV in this example","title":"Create your own DAO"},{"location":"tutorials/create-a-dao/#dao-creator","text":"DAOcreator is a tool that allows you to deploy your DAO in a super simple way. It has a UI which you can find in Alchemy dApp When you create a DAO, it create an instance of the multiple components defined in Arc Deploying a DAO with this tool consists of three steps which are: 1- Setting the DAO name and symbol 2- Configure proposals parameters 3- Define the members of your organization Let's go step by step and what every step does:","title":"DAO creator"},{"location":"tutorials/create-a-dao/#setting-the-dao-name-and-symbol","text":"In this section, you will set the DAO's name and the Token's symbol.","title":"Setting the DAO name and symbol"},{"location":"tutorials/create-a-dao/#configure-proposals-parameters","text":"Here you will define the mechanics of the proposals, from here you can choose the amount of time allotted for votes to come to a close when it comes to making decisions. Choose \u201cSlow\u201d, \u201cMedium\u201d, or \u201cFast\u201d depending on how long you want the voting periods to be. If you\u2019d like to know how long each setting is, simply hover over the buttons to know how many days are given for each type of vote. Then you can choose to add three options, which are: Reward successful proposer: If the proposal passes, the proposer will get a certain amount of REP Reward correct voters and penalize incorrect voters: If the proposal is boosted, the stakers that did the bet for the winning result will get a certain amount of REP Auto-incentivize proposal curation: When a proposal is created, the organization will bet agaisnt the proposal If you are a experienced user in the stack the advanced configuration allows you to configure the voting mechanics as you desire. Please refer to Genesis Protocol documentation to know what the parameters are and what they do.","title":"Configure proposals parameters"},{"location":"tutorials/create-a-dao/#define-the-members","text":"Here you will be able to add the addresses of whichever members you would like to be a part of the DAO. You will be able to vote to add more members at a later date, but if you have their addresses now, it\u2019s best to get that done now. Each member will be identified by their eth address, so make sure each one is inserted correctly.","title":"Define the members"},{"location":"tutorials/create-a-dao/#misc","text":"","title":"Misc"},{"location":"tutorials/create-a-dao/#exportimport-config","text":"The DAOcreator allows you to import/export the entire configuration of your DAO. In case you already have your set up but want to send it to someone or wait for another address. You can get the migration-params.json file from the Export configuration button.","title":"Export/Import config"},{"location":"tutorials/create-a-dao/#import-members","text":"On the Add members section, there is a button at the top right, that allows you to import a CSV with the members. You can check how to create this CSV in this example","title":"Import members"},{"location":"tutorials/register-a-plugin/","text":"","title":"Register a plugin"},{"location":"tutorials/test-environment/","text":"","title":"Test environment"},{"location":"tutorials/register-a-plugin/alchemy/","text":"Registering a Plugin in Alchemy Registering the plugin's name In the pluginUtils.ts file, typically under src/lib , there's a PLUGIN_NAMES object: export const PLUGIN_NAMES = { ContributionReward: \"Funding and Voting Power\", GenericScheme: \"Generic Plugin\", ReputationFromToken: \"Reputation from Token\", SchemeRegistrar: \"Plugin Registrar\", SchemeFactory: \"Plugin Manager\", Competition: \"Competition\", TokenTrade: \"Token Trade\", ContributionRewardExt: \"Contribution Reward Ext\", Join: \"Join\", FundingRequest: \"Funding Request\", }; Add the new plugin to that object. Creating the CreateProposal form component Alchemy typically uses class based React components. And the naming convention is usually: Create + Plugin Name + Proposal. Example: CreateContributionRewardProposal . 1. Declaring Form Values The first step is to declare an IFormValues interface that describes all of the Create Proposal form fields . This interface should always contain at least the following properties: interface IFormValues { description: string; title: string; url: string; tags: Array<string> } A full example of this interface can be found in the CreateTokenTradeProposal component: interface IFormValues { description: string; title: string; url: string; tags: Array<string>; sendTokenAddress: string, sendTokenAmount: number, receiveTokenAddress: string, receiveTokenAmount: number, } The next step is to create a function that returns an IFormValues object with the proper initial values of each field. Following the CreateTokenTradeProposal 's IFormValues example, its initializing function would be: const setInitialFormValues = (): IFormValues => { return Object.freeze({ description: \"\", title: \"\", url: \"\", tags: [], sendTokenAddress: \"\", sendTokenAmount: 0, receiveTokenAddress: \"\", receiveTokenAmount: 0, }); }; Lastly, declare a currentFormValues class property of type IFormValues in the CreateProposal component: class CreateExamplePluginProposal extends React.Component<IProps, IState> { currentFormValues: IFormValues; constructor(props: IProps) { super(props); ... } ... } 2. Creating a FormModalService instance Alchemy's CreateProposal form components make use of the FormModalService , which handles form state changes and notifications. To use it, an instance of it is typically declared as a class property and created in the constructor: class CreateExamplePluginProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } From the example above, you will notice the CreateFormModalService function takes 5 arguments: formName defaultValues valuesToPersist updateCurrentValues showNotification 3. Initializing the state object Sometimes it is necessary to persist form-relevant values across re-renders, that are not directly form values. Like an array with all possible dropdown options. This is always the case with proposal tags. Therefore, they should always be initialized in the constructor like this: class CreateTokenTradeProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.state = { tags: [] }; this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } 4. Creating the form's markup Inside the class Component's render function a Formik component should be declared. This component takes 4 arguments: initialValues : we will pass this.currentFormValues here. validate : we will pass a Formik validation function here, like this one: (values: IFormValues) => { this.currentFormValues = values; const errors: any = {}; const require = (name: string) => { if (!(values as any)[name]) { errors[name] = \"Required\"; } }; require(\"description\"); require(\"title\"); if (values.title.length > 120) { errors.title = \"Title is too long (max 120 characters)\"; } if (!isValidUrl(values.url)) { errors.url = \"Invalid URL\"; } return errors; } onSubmit : we will pass the class's handleSubmit method (explained in detail in the following sections). render : here is where the actual CreateProposal form's markup will live. Here we pass a functional component that has all form relevant props injected by Formik and will return the form's markup: ({ errors, touched, isSubmitting, setFieldValue, values, }: FormikProps<IFormValues>) => { return ( <Form noValidate> <label className={css.description}>What to Expect</label> <div className={css.description}>Propose to trade tokens with the DAO.</div> <TrainingTooltip overlay={i18next.t(\"Title Tooltip\")} placement=\"right\"> <label htmlFor=\"titleInput\"> <div className={css.requiredMarker}>*</div> Title <ErrorMessage name=\"title\">{(msg) => <span className={css.errorMessage}>{msg}</span>}</ErrorMessage> </label> </TrainingTooltip> <Field autoFocus id=\"titleInput\" maxLength={120} placeholder={i18next.t(\"Title Placeholder\")} name=\"title\" type=\"text\" className={touched.title && errors.title ? css.error : null} /> ... </Form> )} } It is worth noting the following conventions to write the form's markup: i18next should be used for all form labels, notifications and messages. There should be a TrainingTooltip component above each Field with a description relevant to said field. Styling is declared in a separate Sass file. 5. Creating the handleSubmit method This method should be private and asynchronous. It, mainly, checks if the Wallet Provider is enabled, maps form values to an Arc.js proposalOptions object, awaits proposal creation through an Arc.js createProposal call, and tracks analytics on proposal submission. A full example of this is the TokenTrade 's handleSubmit method: private handleSubmit = async (values: IFormValues, { setSubmitting }: any ): Promise<void> => { if (!await enableWalletProvider({ showNotification: this.props.showNotification })) { return; } const proposalOptions = { dao: this.props.daoAvatarAddress, description: values.description, title: values.title, tags: this.state.tags, plugin: this.props.pluginState.address, url: values.url, sendTokenAddress: values.sendTokenAddress, sendTokenAmount: values.sendTokenAmount, receiveTokenAddress: values.receiveTokenAddress, receiveTokenAmount: values.receiveTokenAmount, }; setSubmitting(false); await this.props.createProposal(proposalOptions); Analytics.track(\"Submit Proposal\", { \"DAO Address\": this.props.daoAvatarAddress, \"Proposal Title\": values.title, \"Plugin Address\": this.props.pluginState.address, \"Plugin Name\": this.props.pluginState.name, }); this.props.handleClose(); } It is worth mentioning that dao address and plugin address options are taken from the component's props. More on this in the following sections. Registering the Form For this component to be used it needs to be added to the CreateProposalPage.tsx file. Go to this file, typically under src/components/Proposal/Create . You will notice the CreateProposalPage component: class CreateProposalPage extends React.Component<IProps, IStateProps> { constructor(props: IProps) { super(props); this.state = { createCrxProposalComponent: null, }; } ... public render(): RenderOutput { const { daoAvatarAddress, currentAccountAddress } = this.props; const plugin = this.props.data; const pluginState = plugin.coreState; let createPluginComponent = <div />; const props = { currentAccountAddress, daoAvatarAddress, handleClose: this.doClose, plugin, }; const pluginTitle = this.state.createCrxProposalComponent ? rewarderContractName(pluginState as IContributionRewardExtState) : pluginName(pluginState); if (this.state.createCrxProposalComponent) { createPluginComponent = <this.state.createCrxProposalComponent {...props} />; } else if (pluginState.name === \"ContributionReward\") { createPluginComponent = <CreateContributionRewardProposal {...props} pluginState={pluginState as IContributionRewardState} />; } else if (pluginState.name === \"SchemeRegistrar\") { createPluginComponent = <CreatePluginRegistrarProposal {...props} pluginState={pluginState as IPluginRegistrarState} />; } else if (pluginState.name === \"SchemeFactory\") { createPluginComponent = <CreatePluginManagerProposal {...props} pluginState={pluginState as IPluginManagerState} />; } else if (pluginState.name === \"TokenTrade\") { createPluginComponent = <CreateTokenTradeProposal {...props} pluginState={pluginState as ITokenTradeState} />; } else if (pluginState.name === \"GenericScheme\") { const contractToCall = (pluginState as IGenericPluginState).pluginParams.contractToCall; if (!contractToCall) { throw Error(\"No contractToCall for this genericPlugin was found!\"); } const genericPluginRegistry = new GenericPluginRegistry(); const genericPluginInfo = genericPluginRegistry.getPluginInfo(contractToCall); if (genericPluginInfo) { createPluginComponent = <CreateKnownGenericPluginProposal {...props} genericPluginInfo={genericPluginInfo} pluginState={pluginState as IGenericPluginState} />; } else { createPluginComponent = <CreateUnknownGenericPluginProposal {...props} pluginState={pluginState as IGenericPluginState} />; } } ... } } Then on the render method of the CreateProposalPage declared there, add a condition to make the createPluginComponent variable be the CreateProposalForm you created in the previous section, if the pluginState's name matches the proposal's plugin. Your CreateProposalForm component in this method will take the CreateProposalPage 's deconstructed props: {...props} and a pluginState object which must be casted to an Arc.js Plugin State interface. Make created proposal redeemable In order to make a proposal created through your CreateProposalForm redeemable, you must register it in the arcActions file. Typically under: src/actions , the file will contain a tryRedeemProposal function: async function tryRedeemProposal(proposalId: string, accountAddress: string, observer: any) { const arc = getArc(); const proposal = await Proposal.create(arc, proposalId); switch (proposal.coreState.name) { case \"GenericScheme\": case \"ContributionReward\": case \"Competition\": case \"ContributionRewardExt\": case \"SchemeRegistrarRemove\": case \"SchemeRegistrarAdd\": case \"SchemeRegistrar\": case \"SchemeFactory\": await (proposal as Proposal<IProposalState>).redeemRewards( accountAddress ).subscribe(...observer); break; case \"FundingRequest\": await (proposal as FundingRequestProposal).redeem().subscribe(...observer); break; case \"Join\": await (proposal as JoinProposal).redeem().subscribe(...observer); break; case \"TokenTrade\": await (proposal as TokenTradeProposal).redeem().subscribe(...observer); break; default: break; } return Promise.resolve(); } There, add a case to the already existing switch , with the proposal's plugin name. Inside, cast the proposal object to the corresponding Arc.js Proposal Class, call redeem and subscribe on it and await it, just like in the example above. Registering the plugin in the Plugin Manager In the PluginManager 's CreateProposal form, the following additions are needed so that the new plugin can be created from a plugin manager proposal: In the plugin manager's IFormValues interface: export interface IFormValues { description: string; currentTab: ITab; tags: Array<string>; title: string; url: string; pluginToRemove: string; pluginToAdd: PluginNames | \"\"; GenericScheme: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; contractToCall: string; }; ContributionReward: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; Competition: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; ... } add the new plugin's initialize parameters. In the plugin manager's defaultValues object, declare the initial default values for the initialize parameters declared in the previous step: const defaultValues: IFormValues = { description: \"\", pluginToAdd: \"\", pluginToRemove: \"\", title: \"\", url: \"\", currentTab: \"addPlugin\", tags: [], GenericScheme: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: true, }, contractToCall: \"\", }, ContributionReward: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: false, }, }, ... } In the plugin manager's handleSubmit method, add a case to the already existing switch for creation and replacement proposals. The case added must populate the plugin's initialize parameters: if (currentTab === \"addPlugin\" || currentTab === \"replacePlugin\") { (proposalOptions.add as any) = { pluginName: values.pluginToAdd, }; switch (proposalOptions.add.pluginName) { case \"Competition\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.Competition.votingParams), voteOnBehalf: values.Competition.votingParams.voteOnBehalf, voteParamsHash: values.Competition.votingParams.voteParamsHash, daoFactory: arc.getContractInfoByName(\"DAOFactoryInstance\", LATEST_ARC_VERSION).address, packageVersion: packageVersion, rewarderName: \"Competition\", }; break; case \"ContributionReward\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.ContributionReward.votingParams), voteOnBehalf: values.ContributionReward.votingParams.voteOnBehalf, voteParamsHash: values.ContributionReward.votingParams.voteParamsHash, }; break; ... } ... } Additionally, so that the plugin manager's form can properly render the initialize parameters fields for the new plugin, go to the PluginInitializeFields.ts file, typically under src/components/Proposal/Create : ... const TokenTrade = () => ( <div> {GenesisProtocolFields(\"TokenTrade.votingParams\")} </div> ); const ReputationFromTokenFields = () => ( <div> {fieldView(\"ReputationFromToken\", \"Token Contract\", \"tokenContract\")} {fieldView(\"ReputationFromToken\", \"Curve Interface\", \"curveInterface\")} </div> ); const fieldsMap = { GenericScheme: GenericSchemeFields, ContributionReward: ContributionRewardFields, Competition: CompetitionFields, ContributionRewardExt: ContributionRewardExtFields, FundingRequest: FundingRequest, Join: Join, TokenTrade: TokenTrade, SchemeRegistrar: SchemeRegistrarFields, SchemeFactory: PluginManagerFields, ReputationFromToken: ReputationFromTokenFields, }; ... There, 2 additions are necessary: Create a function that returns each initialize parameter field for the new plugin. This is done, using the fieldView function that takes 3 arguments: pluginName, initializeParameterName, fieldName. See the code snippet above. Add the created funcion to the fieldsMap object. Create the Proposal Summary page Each plugin should have its ProposalSummary page along with its CreateProposal form. This summary will contain the relevant proposal information that will be shown after the proposal has been created. It follows a simple class based Component pattern. For example, TokenTrade 's proposal summary looks like this: export default class ProposalSummaryTokenTrade extends React.Component<IProps> { constructor(props: IProps) { super(props); } public render(): RenderOutput { const { beneficiaryProfile, proposalState, daoState, detailView, transactionModal } = this.props; let receiveToken; let sendToken; if (proposalState.sendTokenAddress && proposalState.sendTokenAmount) { const tokenData = tokenDetails(proposalState.sendTokenAddress); sendToken = formatTokens(toWei(Number(proposalState.sendTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } if (proposalState.receiveTokenAddress && proposalState.receiveTokenAmount) { const tokenData = tokenDetails(proposalState.receiveTokenAddress); receiveToken = formatTokens(toWei(Number(proposalState.receiveTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); return ( <div className={proposalSummaryClass}> <span className={css.transferType}> { sendToken && <div> <div> <span className={css.bold}>{i18next.t(\"Send to DAO\")}:</span> </div> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> {receiveToken} </div> } { receiveToken && <div> <div> <span className={css.bold}>{i18next.t(\"Receive from DAO\")}:</span> </div> {receiveToken} <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> </div> } </span> </div> ); } } It is worth noting: All labels and messages use i18next Css is declared separately There are already handy components like AccountPopup and AccountProfileName to display Account information consistently. Registering the Proposal Summary Page In the ProposalSummary.tsx file, typically under src/components/Proposal/ProposalSummary : export default class ProposalSummary extends React.Component<IProps, IState> { ... public render(): RenderOutput { if (!this.state) { return null; } const { detailView, transactionModal } = this.props; const { proposal } = this.state; const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); if (proposal.coreState.name === \"ContributionReward\") { const state = proposal.coreState as IContributionRewardProposalState; return <ProposalSummaryContributionReward {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"SchemeRegistrar\")) { const state = proposal.coreState as IPluginRegistrarProposalState; return <ProposalSummaryPluginRegistrar {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"TokenTrade\")) { const state = proposal.coreState as ITokenTradeProposalState; return <ProposalSummaryTokenTrade {...this.props} proposalState={state} />; } ... } Add a condition that will handle the case where the proposal's state name matches the new plugin's name. Inside this condition cast the proposal.coreState to the corresponding Arc.js ProposalState class. Then return the ProposalSummary component created on the previous section, and pass as props {...this.props} and a proposalState object which will be the casted proposal.coreState .","title":"Alchemy"},{"location":"tutorials/register-a-plugin/alchemy/#registering-a-plugin-in-alchemy","text":"","title":"Registering a Plugin in Alchemy"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-plugins-name","text":"In the pluginUtils.ts file, typically under src/lib , there's a PLUGIN_NAMES object: export const PLUGIN_NAMES = { ContributionReward: \"Funding and Voting Power\", GenericScheme: \"Generic Plugin\", ReputationFromToken: \"Reputation from Token\", SchemeRegistrar: \"Plugin Registrar\", SchemeFactory: \"Plugin Manager\", Competition: \"Competition\", TokenTrade: \"Token Trade\", ContributionRewardExt: \"Contribution Reward Ext\", Join: \"Join\", FundingRequest: \"Funding Request\", }; Add the new plugin to that object.","title":"Registering the plugin's name"},{"location":"tutorials/register-a-plugin/alchemy/#creating-the-createproposal-form-component","text":"Alchemy typically uses class based React components. And the naming convention is usually: Create + Plugin Name + Proposal. Example: CreateContributionRewardProposal .","title":"Creating the CreateProposal form component"},{"location":"tutorials/register-a-plugin/alchemy/#1-declaring-form-values","text":"The first step is to declare an IFormValues interface that describes all of the Create Proposal form fields . This interface should always contain at least the following properties: interface IFormValues { description: string; title: string; url: string; tags: Array<string> } A full example of this interface can be found in the CreateTokenTradeProposal component: interface IFormValues { description: string; title: string; url: string; tags: Array<string>; sendTokenAddress: string, sendTokenAmount: number, receiveTokenAddress: string, receiveTokenAmount: number, } The next step is to create a function that returns an IFormValues object with the proper initial values of each field. Following the CreateTokenTradeProposal 's IFormValues example, its initializing function would be: const setInitialFormValues = (): IFormValues => { return Object.freeze({ description: \"\", title: \"\", url: \"\", tags: [], sendTokenAddress: \"\", sendTokenAmount: 0, receiveTokenAddress: \"\", receiveTokenAmount: 0, }); }; Lastly, declare a currentFormValues class property of type IFormValues in the CreateProposal component: class CreateExamplePluginProposal extends React.Component<IProps, IState> { currentFormValues: IFormValues; constructor(props: IProps) { super(props); ... } ... }","title":"1. Declaring Form Values"},{"location":"tutorials/register-a-plugin/alchemy/#2-creating-a-formmodalservice-instance","text":"Alchemy's CreateProposal form components make use of the FormModalService , which handles form state changes and notifications. To use it, an instance of it is typically declared as a class property and created in the constructor: class CreateExamplePluginProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); } From the example above, you will notice the CreateFormModalService function takes 5 arguments: formName defaultValues valuesToPersist updateCurrentValues showNotification","title":"2. Creating a FormModalService instance"},{"location":"tutorials/register-a-plugin/alchemy/#3-initializing-the-state-object","text":"Sometimes it is necessary to persist form-relevant values across re-renders, that are not directly form values. Like an array with all possible dropdown options. This is always the case with proposal tags. Therefore, they should always be initialized in the constructor like this: class CreateTokenTradeProposal extends React.Component<IProps, IState> { formModalService: IFormModalService<IFormValues>; currentFormValues: IFormValues; constructor(props: IProps) { super(props); this.state = { tags: [] }; this.formModalService = CreateFormModalService( \"CreateExamplePluginProposal\", setInitialFormValues(), () => Object.assign(this.currentFormValues, this.state), (formValues: IFormValues, firstTime: boolean) => { this.currentFormValues = formValues; if (firstTime) { this.state = { tags: formValues.tags }; } else { this.setState({ tags: formValues.tags }); } }, this.props.showNotification); }","title":"3. Initializing the state object"},{"location":"tutorials/register-a-plugin/alchemy/#4-creating-the-forms-markup","text":"Inside the class Component's render function a Formik component should be declared. This component takes 4 arguments: initialValues : we will pass this.currentFormValues here. validate : we will pass a Formik validation function here, like this one: (values: IFormValues) => { this.currentFormValues = values; const errors: any = {}; const require = (name: string) => { if (!(values as any)[name]) { errors[name] = \"Required\"; } }; require(\"description\"); require(\"title\"); if (values.title.length > 120) { errors.title = \"Title is too long (max 120 characters)\"; } if (!isValidUrl(values.url)) { errors.url = \"Invalid URL\"; } return errors; } onSubmit : we will pass the class's handleSubmit method (explained in detail in the following sections). render : here is where the actual CreateProposal form's markup will live. Here we pass a functional component that has all form relevant props injected by Formik and will return the form's markup: ({ errors, touched, isSubmitting, setFieldValue, values, }: FormikProps<IFormValues>) => { return ( <Form noValidate> <label className={css.description}>What to Expect</label> <div className={css.description}>Propose to trade tokens with the DAO.</div> <TrainingTooltip overlay={i18next.t(\"Title Tooltip\")} placement=\"right\"> <label htmlFor=\"titleInput\"> <div className={css.requiredMarker}>*</div> Title <ErrorMessage name=\"title\">{(msg) => <span className={css.errorMessage}>{msg}</span>}</ErrorMessage> </label> </TrainingTooltip> <Field autoFocus id=\"titleInput\" maxLength={120} placeholder={i18next.t(\"Title Placeholder\")} name=\"title\" type=\"text\" className={touched.title && errors.title ? css.error : null} /> ... </Form> )} } It is worth noting the following conventions to write the form's markup: i18next should be used for all form labels, notifications and messages. There should be a TrainingTooltip component above each Field with a description relevant to said field. Styling is declared in a separate Sass file.","title":"4. Creating the form's markup"},{"location":"tutorials/register-a-plugin/alchemy/#5-creating-the-handlesubmit-method","text":"This method should be private and asynchronous. It, mainly, checks if the Wallet Provider is enabled, maps form values to an Arc.js proposalOptions object, awaits proposal creation through an Arc.js createProposal call, and tracks analytics on proposal submission. A full example of this is the TokenTrade 's handleSubmit method: private handleSubmit = async (values: IFormValues, { setSubmitting }: any ): Promise<void> => { if (!await enableWalletProvider({ showNotification: this.props.showNotification })) { return; } const proposalOptions = { dao: this.props.daoAvatarAddress, description: values.description, title: values.title, tags: this.state.tags, plugin: this.props.pluginState.address, url: values.url, sendTokenAddress: values.sendTokenAddress, sendTokenAmount: values.sendTokenAmount, receiveTokenAddress: values.receiveTokenAddress, receiveTokenAmount: values.receiveTokenAmount, }; setSubmitting(false); await this.props.createProposal(proposalOptions); Analytics.track(\"Submit Proposal\", { \"DAO Address\": this.props.daoAvatarAddress, \"Proposal Title\": values.title, \"Plugin Address\": this.props.pluginState.address, \"Plugin Name\": this.props.pluginState.name, }); this.props.handleClose(); } It is worth mentioning that dao address and plugin address options are taken from the component's props. More on this in the following sections.","title":"5. Creating the handleSubmit method"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-form","text":"For this component to be used it needs to be added to the CreateProposalPage.tsx file. Go to this file, typically under src/components/Proposal/Create . You will notice the CreateProposalPage component: class CreateProposalPage extends React.Component<IProps, IStateProps> { constructor(props: IProps) { super(props); this.state = { createCrxProposalComponent: null, }; } ... public render(): RenderOutput { const { daoAvatarAddress, currentAccountAddress } = this.props; const plugin = this.props.data; const pluginState = plugin.coreState; let createPluginComponent = <div />; const props = { currentAccountAddress, daoAvatarAddress, handleClose: this.doClose, plugin, }; const pluginTitle = this.state.createCrxProposalComponent ? rewarderContractName(pluginState as IContributionRewardExtState) : pluginName(pluginState); if (this.state.createCrxProposalComponent) { createPluginComponent = <this.state.createCrxProposalComponent {...props} />; } else if (pluginState.name === \"ContributionReward\") { createPluginComponent = <CreateContributionRewardProposal {...props} pluginState={pluginState as IContributionRewardState} />; } else if (pluginState.name === \"SchemeRegistrar\") { createPluginComponent = <CreatePluginRegistrarProposal {...props} pluginState={pluginState as IPluginRegistrarState} />; } else if (pluginState.name === \"SchemeFactory\") { createPluginComponent = <CreatePluginManagerProposal {...props} pluginState={pluginState as IPluginManagerState} />; } else if (pluginState.name === \"TokenTrade\") { createPluginComponent = <CreateTokenTradeProposal {...props} pluginState={pluginState as ITokenTradeState} />; } else if (pluginState.name === \"GenericScheme\") { const contractToCall = (pluginState as IGenericPluginState).pluginParams.contractToCall; if (!contractToCall) { throw Error(\"No contractToCall for this genericPlugin was found!\"); } const genericPluginRegistry = new GenericPluginRegistry(); const genericPluginInfo = genericPluginRegistry.getPluginInfo(contractToCall); if (genericPluginInfo) { createPluginComponent = <CreateKnownGenericPluginProposal {...props} genericPluginInfo={genericPluginInfo} pluginState={pluginState as IGenericPluginState} />; } else { createPluginComponent = <CreateUnknownGenericPluginProposal {...props} pluginState={pluginState as IGenericPluginState} />; } } ... } } Then on the render method of the CreateProposalPage declared there, add a condition to make the createPluginComponent variable be the CreateProposalForm you created in the previous section, if the pluginState's name matches the proposal's plugin. Your CreateProposalForm component in this method will take the CreateProposalPage 's deconstructed props: {...props} and a pluginState object which must be casted to an Arc.js Plugin State interface.","title":"Registering the Form"},{"location":"tutorials/register-a-plugin/alchemy/#make-created-proposal-redeemable","text":"In order to make a proposal created through your CreateProposalForm redeemable, you must register it in the arcActions file. Typically under: src/actions , the file will contain a tryRedeemProposal function: async function tryRedeemProposal(proposalId: string, accountAddress: string, observer: any) { const arc = getArc(); const proposal = await Proposal.create(arc, proposalId); switch (proposal.coreState.name) { case \"GenericScheme\": case \"ContributionReward\": case \"Competition\": case \"ContributionRewardExt\": case \"SchemeRegistrarRemove\": case \"SchemeRegistrarAdd\": case \"SchemeRegistrar\": case \"SchemeFactory\": await (proposal as Proposal<IProposalState>).redeemRewards( accountAddress ).subscribe(...observer); break; case \"FundingRequest\": await (proposal as FundingRequestProposal).redeem().subscribe(...observer); break; case \"Join\": await (proposal as JoinProposal).redeem().subscribe(...observer); break; case \"TokenTrade\": await (proposal as TokenTradeProposal).redeem().subscribe(...observer); break; default: break; } return Promise.resolve(); } There, add a case to the already existing switch , with the proposal's plugin name. Inside, cast the proposal object to the corresponding Arc.js Proposal Class, call redeem and subscribe on it and await it, just like in the example above.","title":"Make created proposal redeemable"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-plugin-in-the-plugin-manager","text":"In the PluginManager 's CreateProposal form, the following additions are needed so that the new plugin can be created from a plugin manager proposal: In the plugin manager's IFormValues interface: export interface IFormValues { description: string; currentTab: ITab; tags: Array<string>; title: string; url: string; pluginToRemove: string; pluginToAdd: PluginNames | \"\"; GenericScheme: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; contractToCall: string; }; ContributionReward: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; Competition: { permissions: IPermissions; votingParams: IGenesisProtocolFormValues; }; ... } add the new plugin's initialize parameters. In the plugin manager's defaultValues object, declare the initial default values for the initialize parameters declared in the previous step: const defaultValues: IFormValues = { description: \"\", pluginToAdd: \"\", pluginToRemove: \"\", title: \"\", url: \"\", currentTab: \"addPlugin\", tags: [], GenericScheme: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: true, }, contractToCall: \"\", }, ContributionReward: { votingParams: { ...votingParams }, permissions: { registerPlugins: false, changeConstraints: false, upgradeController: false, genericCall: false, }, }, ... } In the plugin manager's handleSubmit method, add a case to the already existing switch for creation and replacement proposals. The case added must populate the plugin's initialize parameters: if (currentTab === \"addPlugin\" || currentTab === \"replacePlugin\") { (proposalOptions.add as any) = { pluginName: values.pluginToAdd, }; switch (proposalOptions.add.pluginName) { case \"Competition\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.Competition.votingParams), voteOnBehalf: values.Competition.votingParams.voteOnBehalf, voteParamsHash: values.Competition.votingParams.voteParamsHash, daoFactory: arc.getContractInfoByName(\"DAOFactoryInstance\", LATEST_ARC_VERSION).address, packageVersion: packageVersion, rewarderName: \"Competition\", }; break; case \"ContributionReward\": proposalOptions.add.pluginInitParams = { daoId: daoId, votingMachine: votingMachine, votingParams: gpFormValuesToVotingParams(values.ContributionReward.votingParams), voteOnBehalf: values.ContributionReward.votingParams.voteOnBehalf, voteParamsHash: values.ContributionReward.votingParams.voteParamsHash, }; break; ... } ... } Additionally, so that the plugin manager's form can properly render the initialize parameters fields for the new plugin, go to the PluginInitializeFields.ts file, typically under src/components/Proposal/Create : ... const TokenTrade = () => ( <div> {GenesisProtocolFields(\"TokenTrade.votingParams\")} </div> ); const ReputationFromTokenFields = () => ( <div> {fieldView(\"ReputationFromToken\", \"Token Contract\", \"tokenContract\")} {fieldView(\"ReputationFromToken\", \"Curve Interface\", \"curveInterface\")} </div> ); const fieldsMap = { GenericScheme: GenericSchemeFields, ContributionReward: ContributionRewardFields, Competition: CompetitionFields, ContributionRewardExt: ContributionRewardExtFields, FundingRequest: FundingRequest, Join: Join, TokenTrade: TokenTrade, SchemeRegistrar: SchemeRegistrarFields, SchemeFactory: PluginManagerFields, ReputationFromToken: ReputationFromTokenFields, }; ... There, 2 additions are necessary: Create a function that returns each initialize parameter field for the new plugin. This is done, using the fieldView function that takes 3 arguments: pluginName, initializeParameterName, fieldName. See the code snippet above. Add the created funcion to the fieldsMap object.","title":"Registering the plugin in the Plugin Manager"},{"location":"tutorials/register-a-plugin/alchemy/#create-the-proposal-summary-page","text":"Each plugin should have its ProposalSummary page along with its CreateProposal form. This summary will contain the relevant proposal information that will be shown after the proposal has been created. It follows a simple class based Component pattern. For example, TokenTrade 's proposal summary looks like this: export default class ProposalSummaryTokenTrade extends React.Component<IProps> { constructor(props: IProps) { super(props); } public render(): RenderOutput { const { beneficiaryProfile, proposalState, daoState, detailView, transactionModal } = this.props; let receiveToken; let sendToken; if (proposalState.sendTokenAddress && proposalState.sendTokenAmount) { const tokenData = tokenDetails(proposalState.sendTokenAddress); sendToken = formatTokens(toWei(Number(proposalState.sendTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } if (proposalState.receiveTokenAddress && proposalState.receiveTokenAmount) { const tokenData = tokenDetails(proposalState.receiveTokenAddress); receiveToken = formatTokens(toWei(Number(proposalState.receiveTokenAmount)), tokenData ? tokenData[\"symbol\"] : \"?\", tokenData ? tokenData[\"decimals\"] : 18); } const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); return ( <div className={proposalSummaryClass}> <span className={css.transferType}> { sendToken && <div> <div> <span className={css.bold}>{i18next.t(\"Send to DAO\")}:</span> </div> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> {receiveToken} </div> } { receiveToken && <div> <div> <span className={css.bold}>{i18next.t(\"Receive from DAO\")}:</span> </div> {receiveToken} <span className={css.transferAmount}></span> <img className={css.transferIcon} src=\"/assets/images/Icon/Transfer.svg\" /> <AccountPopup accountAddress={proposalState.beneficiary} daoState={daoState} width={12} /> <span> <AccountProfileName accountAddress={proposalState.beneficiary} accountProfile={beneficiaryProfile} daoAvatarAddress={daoState.address}/> </span> </div> } </span> </div> ); } } It is worth noting: All labels and messages use i18next Css is declared separately There are already handy components like AccountPopup and AccountProfileName to display Account information consistently.","title":"Create the Proposal Summary page"},{"location":"tutorials/register-a-plugin/alchemy/#registering-the-proposal-summary-page","text":"In the ProposalSummary.tsx file, typically under src/components/Proposal/ProposalSummary : export default class ProposalSummary extends React.Component<IProps, IState> { ... public render(): RenderOutput { if (!this.state) { return null; } const { detailView, transactionModal } = this.props; const { proposal } = this.state; const proposalSummaryClass = classNames({ [css.detailView]: detailView, [css.transactionModal]: transactionModal, [css.proposalSummary]: true, }); if (proposal.coreState.name === \"ContributionReward\") { const state = proposal.coreState as IContributionRewardProposalState; return <ProposalSummaryContributionReward {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"SchemeRegistrar\")) { const state = proposal.coreState as IPluginRegistrarProposalState; return <ProposalSummaryPluginRegistrar {...this.props} proposalState={state} />; } else if (proposal.coreState.name.includes(\"TokenTrade\")) { const state = proposal.coreState as ITokenTradeProposalState; return <ProposalSummaryTokenTrade {...this.props} proposalState={state} />; } ... } Add a condition that will handle the case where the proposal's state name matches the new plugin's name. Inside this condition cast the proposal.coreState to the corresponding Arc.js ProposalState class. Then return the ProposalSummary component created on the previous section, and pass as props {...this.props} and a proposalState object which will be the casted proposal.coreState .","title":"Registering the Proposal Summary Page"},{"location":"tutorials/register-a-plugin/arc/","text":"","title":"Arc"},{"location":"tutorials/register-a-plugin/arcjs/","text":"Registering a Plugin in Arc.js Creating the folder structure To register a new plugin, add a folder in the src/plugins folder, with the name of the plugin to register and create 3 files: proposal.ts plugin.ts index.ts The index file is always the same: export * from './plugin' export * from './proposal' The Plugin class definition will live in the plugin.ts file and the Proposal class definition will live in the proposal.ts file. Creating the Plugin class Interfaces The first step is to create 3 necessary interfaces: Plugin State : it describes the plugin state and must extend IPluginState interface. Typically it just adds the pluginParams field. Example with the TokenTrade plugin: export interface ITokenTradeState extends IPluginState { pluginParams: { votingMachine: Address voteParams: IGenesisProtocolParams } } Proposal Creation Options : it describes the arguments to pass to the proposal creation method. Must extend the IProposalBaseCreateOptions . Base options like dao address are already declared in the IProposalBaseCreateOptions interface. Example with the TokenTrade plugin: export interface IProposalCreateOptionsTokenTrade extends IProposalBaseCreateOptions { sendTokenAddress: Address, sendTokenAmount: number, receiveTokenAddress: Address, receiveTokenAmount: number, descriptionHash: string } Initialize Parameters : it describes the parameters to pass to the initialize contract method. Example with the TokenTrade plugin: export interface IInitParamsTT { daoId: string votingMachine: string votingParams: number[] voteOnBehalf: string voteParamsHash: string } Class definition If the plugin can create proposals, it must extend the ProposalPlugin class, if it can't, then it must extend the Plugin class. For this example, we will be using the TokenTrade plugin. The next step is to declare the class and make it extend ProposalPlugin , passing the 3 interfaces created in the previous section as type parameters: export class TokenTrade extends ProposalPlugin< ITokenTradeState, ITokenTradeProposalState, IProposalCreateOptionsTokenTrade> {... } Item Map Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState The goal of this method is to map the item object received by a query to an object of its interface. Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. Should return null if it did not return results: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState | null { if (!item) { return null } if (!item.tokenTradeParams) { throw new Error(`Plugin ${queriedId ? `with id '${queriedId}'` : ''}wrongly instantiated as TokenTrade Plugin`) } const baseState = Plugin.itemMapToBaseState(context, item) const tokenTradeParams = { voteParams: mapGenesisProtocolParams(item.tokenTradeParams.voteParams), votingMachine: item.tokenTradeParams.votingMachine } return { ...baseState, pluginParams: tokenTradeParams } } Initialize Params Mapper Next, implement the initializeParamsMap method, which follows the signature: public static initializeParamsMap(initParams: IInitParamsTT) It takes an object with the plugin's initialize parameters and returns an array with the parameters organized in the correct order to be passed to its contract, through the PluginManager : public static initializeParamsMap(initParams: IInitParamsTT) { Object.keys(initParams).forEach((key) => { if (initParams[key] === undefined) { throw new Error(`TokenTrade's initialize parameter '${key}' cannot be undefined`) } }) return [ initParams.daoId, initParams.votingMachine, initParams.votingParams, initParams.voteOnBehalf, initParams.voteParamsHash ] } Fragment Declare the public static fragment getter method and fragmentField private static property: private static fragmentField: { name: string, fragment: DocumentNode } | undefined public static get fragment() { if (!this.fragmentField) { this.fragmentField = { name: 'TokenTradeParams', fragment: gql` fragment TokenTradeParams on ControllerScheme { tokenTradeParams { id votingMachine voteParams { id queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } }` } } return this.fragmentField } Its objective is to include this plugin's specific fields in the general plugin search query. The name used for the actual GraphQL fragment definition must match the name property of the fragmentField property, in this case they both are: 'TokenTradeParams'. Typically the fragment starts with the name of the plugin, camel-cased and followed by 'Params', in this case it is 'tokenTradeParams' Create Proposal Next, implement the createProposalTransactionMap and createProposalErrorHandler , that always follow the same pattern: public createProposalTransactionMap(): transactionResultHandler<any> { return async (receipt: ITransactionReceipt) => { const args = getEventArgs(receipt, 'TokenTradeProposed', 'TokenTrade.createProposal') const proposalId = args[1] return new TokenTradeProposal(this.context, proposalId) } } public createProposalErrorHandler(options: IProposalCreateOptionsTokenTrade): transactionErrorHandler { return async (err) => { throw err } } You would only need to change the name of the event emitted by the contract on proposal creation, and the create proposal method, as shown above. Lastly, implement the createProposalTransaction method. This method has validation logic for each of the proposal creation options, saves the description hash to IPFS if there is none created beforehand and returns an object that contains the plugin's contract address, the name of the contract method to create a proposal and the arguments for it, organized in an array: public async createProposalTransaction(options: IProposalCreateOptionsTokenTrade): Promise<ITransaction> { if (options.plugin === undefined) { throw new Error(`Missing argument \"plugin\" for TokenTrade in Proposal.create()`) } if (!options.receiveTokenAddress) { throw new Error(`Missing argument \"receiveTokenAddress\" for TokenTrade in Proposal.create()`) } if (!options.sendTokenAddress) { throw new Error(`Missing argument \"sendTokenAddress\" for TokenTrade in Proposal.create()`) } if (options.receiveTokenAmount <= 0) { throw new Error(`Argument \"receiveTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (options.sendTokenAmount <= 0) { throw new Error(`Argument \"sendTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (!options.descriptionHash) { options.descriptionHash = await this.context.saveIPFSData(options) } const { address: pluginAddress } = await this.fetchState() await this.context.approveTokens(options.sendTokenAddress, pluginAddress, new BN(options.sendTokenAmount)).send() return { contract: this.context.getContract(pluginAddress), method: 'proposeTokenTrade', args: [ options.sendTokenAddress, options.sendTokenAmount, options.receiveTokenAddress, options.receiveTokenAmount, options.descriptionHash ] } } IMPORTANT NOTE: all other Arc.js entities or classes. used in this class must be imported from the src/index file : import { Address, Arc, getEventArgs, IGenesisProtocolParams, IPluginState, IProposalBaseCreateOptions, ITransaction, ITransactionReceipt, mapGenesisProtocolParams, Plugin, ProposalPlugin, transactionErrorHandler, transactionResultHandler } from '../../index' Registering the Plugin class The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. The Init Params interface must also be imported an mapped into the InitParams object in this file. export const ProposalPlugins = { FundingRequest, Join, GenericScheme: GenericPlugin, SchemeRegistrar: PluginRegistrarPlugin, ContributionReward: ContributionRewardPlugin, TokenTrade, Unknown: UnknownPlugin ... } export const Plugins = { ...ProposalPlugins, ReputationFromToken: ReputationFromTokenPlugin, Unknown: UnknownPlugin } export interface IInitParams { GenericScheme: IInitParamsGS, ContributionReward: IInitParamsCR, Competition: IInitParamsCompetition, ... } export type ProposalCreateOptions = IProposalCreateOptionsCRExt | IProposalCreateOptionsGS | IProposalCreateOptionsSR | ... Creating the Proposal class The Proposal class definition is, in essence, almost the same as the Plugin class definition, with some differences: The only interface that needs to be declared prior to the class creation is the Proposal State interface, which must always extend the IProposalState interface. An example would be: export interface ITokenTradeProposalState extends IProposalState { dao: IEntityRef<DAO> beneficiary: Address sendTokenAddress: Address sendTokenAmount: number receiveTokenAddress: Address receiveTokenAmount: number executed: boolean redeemed: boolean } The proposal class to be created needs to extend the abstract Proposal class, which takes the interface mentioned above as a type parameter: export class TokenTradeProposal extends Proposal<ITokenTradeProposalState> { ... } The state method must be implemented. It always follows the same implementation. You only need to change the Observable 's type parameter with the proper Proposal State interface: public state(apolloQueryOptions: IApolloQueryOptions): Observable<ITokenTradeProposalState> { const query = gql`query ProposalState { proposal(id: \"${this.id}\") { ...ProposalFields votes { id } stakes { id } } } ${Proposal.baseFragment} ${Plugin.baseFragment} ` const result = this.context.getObservableObject( this.context, query, TokenTradeProposal.itemMap, this.id, apolloQueryOptions ) as Observable<ITokenTradeProposalState> return result } The redeem method must be implemented Registering the Proposal Class The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Proposals object, mapped to its subgraph name: export const Proposals = { GenericScheme: GenericPluginProposal, ContributionReward: ContributionRewardProposal, Competition: CompetitionProposal, ContributionRewardExt: ContributionRewardExtProposal, FundingRequest: FundingRequestProposal, TokenTrade: TokenTradeProposal, Join: JoinProposal, SchemeRegistrar: PluginRegistrarProposal, SchemeRegistrarAdd: PluginRegistrarProposal, SchemeRegistrarRemove: PluginRegistrarProposal, SchemeFactory: PluginManagerProposal, Unknown: UnknownProposal } Exporting Plugin and Proposal classes The folder containing the plugin and proposal classes that were just implemented must be exported in the src/index file: export * from './entity' export * from './plugins/plugin' export * from './plugins/proposal' export * from './plugins/proposalPlugin' export * from './plugins/contributionReward' export * from './plugins/contributionRewardExt' export * from './plugins/tokenTrade' ...","title":"Arc.js"},{"location":"tutorials/register-a-plugin/arcjs/#registering-a-plugin-in-arcjs","text":"","title":"Registering a Plugin in Arc.js"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-folder-structure","text":"To register a new plugin, add a folder in the src/plugins folder, with the name of the plugin to register and create 3 files: proposal.ts plugin.ts index.ts The index file is always the same: export * from './plugin' export * from './proposal' The Plugin class definition will live in the plugin.ts file and the Proposal class definition will live in the proposal.ts file.","title":"Creating the folder structure"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-plugin-class","text":"","title":"Creating the Plugin class"},{"location":"tutorials/register-a-plugin/arcjs/#interfaces","text":"The first step is to create 3 necessary interfaces: Plugin State : it describes the plugin state and must extend IPluginState interface. Typically it just adds the pluginParams field. Example with the TokenTrade plugin: export interface ITokenTradeState extends IPluginState { pluginParams: { votingMachine: Address voteParams: IGenesisProtocolParams } } Proposal Creation Options : it describes the arguments to pass to the proposal creation method. Must extend the IProposalBaseCreateOptions . Base options like dao address are already declared in the IProposalBaseCreateOptions interface. Example with the TokenTrade plugin: export interface IProposalCreateOptionsTokenTrade extends IProposalBaseCreateOptions { sendTokenAddress: Address, sendTokenAmount: number, receiveTokenAddress: Address, receiveTokenAmount: number, descriptionHash: string } Initialize Parameters : it describes the parameters to pass to the initialize contract method. Example with the TokenTrade plugin: export interface IInitParamsTT { daoId: string votingMachine: string votingParams: number[] voteOnBehalf: string voteParamsHash: string }","title":"Interfaces"},{"location":"tutorials/register-a-plugin/arcjs/#class-definition","text":"If the plugin can create proposals, it must extend the ProposalPlugin class, if it can't, then it must extend the Plugin class. For this example, we will be using the TokenTrade plugin. The next step is to declare the class and make it extend ProposalPlugin , passing the 3 interfaces created in the previous section as type parameters: export class TokenTrade extends ProposalPlugin< ITokenTradeState, ITokenTradeProposalState, IProposalCreateOptionsTokenTrade> {... }","title":"Class definition"},{"location":"tutorials/register-a-plugin/arcjs/#item-map","text":"Implement the public static itemMap method. This method follows the following signature: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState The goal of this method is to map the item object received by a query to an object of its interface. Proposal and Plugin abstract classes both have an itemMapToBaseState method that eases itemMap implementation and reduces code boilerplate. It takes an optional queriedId parameter. This is the ID passed to the where clause of the GraphQL query. It is passed to have a meaningful error message, in case the query fails or does not yield any results. Should return null if it did not return results: public static itemMap(context: Arc, item: any, queriedId?: string): ITokenTradeState | null { if (!item) { return null } if (!item.tokenTradeParams) { throw new Error(`Plugin ${queriedId ? `with id '${queriedId}'` : ''}wrongly instantiated as TokenTrade Plugin`) } const baseState = Plugin.itemMapToBaseState(context, item) const tokenTradeParams = { voteParams: mapGenesisProtocolParams(item.tokenTradeParams.voteParams), votingMachine: item.tokenTradeParams.votingMachine } return { ...baseState, pluginParams: tokenTradeParams } }","title":"Item Map"},{"location":"tutorials/register-a-plugin/arcjs/#initialize-params-mapper","text":"Next, implement the initializeParamsMap method, which follows the signature: public static initializeParamsMap(initParams: IInitParamsTT) It takes an object with the plugin's initialize parameters and returns an array with the parameters organized in the correct order to be passed to its contract, through the PluginManager : public static initializeParamsMap(initParams: IInitParamsTT) { Object.keys(initParams).forEach((key) => { if (initParams[key] === undefined) { throw new Error(`TokenTrade's initialize parameter '${key}' cannot be undefined`) } }) return [ initParams.daoId, initParams.votingMachine, initParams.votingParams, initParams.voteOnBehalf, initParams.voteParamsHash ] }","title":"Initialize Params Mapper"},{"location":"tutorials/register-a-plugin/arcjs/#fragment","text":"Declare the public static fragment getter method and fragmentField private static property: private static fragmentField: { name: string, fragment: DocumentNode } | undefined public static get fragment() { if (!this.fragmentField) { this.fragmentField = { name: 'TokenTradeParams', fragment: gql` fragment TokenTradeParams on ControllerScheme { tokenTradeParams { id votingMachine voteParams { id queuedVoteRequiredPercentage queuedVotePeriodLimit boostedVotePeriodLimit preBoostedVotePeriodLimit thresholdConst limitExponentValue quietEndingPeriod proposingRepReward votersReputationLossRatio minimumDaoBounty daoBountyConst activationTime voteOnBehalf } } }` } } return this.fragmentField } Its objective is to include this plugin's specific fields in the general plugin search query. The name used for the actual GraphQL fragment definition must match the name property of the fragmentField property, in this case they both are: 'TokenTradeParams'. Typically the fragment starts with the name of the plugin, camel-cased and followed by 'Params', in this case it is 'tokenTradeParams'","title":"Fragment"},{"location":"tutorials/register-a-plugin/arcjs/#create-proposal","text":"Next, implement the createProposalTransactionMap and createProposalErrorHandler , that always follow the same pattern: public createProposalTransactionMap(): transactionResultHandler<any> { return async (receipt: ITransactionReceipt) => { const args = getEventArgs(receipt, 'TokenTradeProposed', 'TokenTrade.createProposal') const proposalId = args[1] return new TokenTradeProposal(this.context, proposalId) } } public createProposalErrorHandler(options: IProposalCreateOptionsTokenTrade): transactionErrorHandler { return async (err) => { throw err } } You would only need to change the name of the event emitted by the contract on proposal creation, and the create proposal method, as shown above. Lastly, implement the createProposalTransaction method. This method has validation logic for each of the proposal creation options, saves the description hash to IPFS if there is none created beforehand and returns an object that contains the plugin's contract address, the name of the contract method to create a proposal and the arguments for it, organized in an array: public async createProposalTransaction(options: IProposalCreateOptionsTokenTrade): Promise<ITransaction> { if (options.plugin === undefined) { throw new Error(`Missing argument \"plugin\" for TokenTrade in Proposal.create()`) } if (!options.receiveTokenAddress) { throw new Error(`Missing argument \"receiveTokenAddress\" for TokenTrade in Proposal.create()`) } if (!options.sendTokenAddress) { throw new Error(`Missing argument \"sendTokenAddress\" for TokenTrade in Proposal.create()`) } if (options.receiveTokenAmount <= 0) { throw new Error(`Argument \"receiveTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (options.sendTokenAmount <= 0) { throw new Error(`Argument \"sendTokenAmount\" must be greater than 0 for TokenTrade in Proposal.create()`) } if (!options.descriptionHash) { options.descriptionHash = await this.context.saveIPFSData(options) } const { address: pluginAddress } = await this.fetchState() await this.context.approveTokens(options.sendTokenAddress, pluginAddress, new BN(options.sendTokenAmount)).send() return { contract: this.context.getContract(pluginAddress), method: 'proposeTokenTrade', args: [ options.sendTokenAddress, options.sendTokenAmount, options.receiveTokenAddress, options.receiveTokenAmount, options.descriptionHash ] } } IMPORTANT NOTE: all other Arc.js entities or classes. used in this class must be imported from the src/index file : import { Address, Arc, getEventArgs, IGenesisProtocolParams, IPluginState, IProposalBaseCreateOptions, ITransaction, ITransactionReceipt, mapGenesisProtocolParams, Plugin, ProposalPlugin, transactionErrorHandler, transactionResultHandler } from '../../index'","title":"Create Proposal"},{"location":"tutorials/register-a-plugin/arcjs/#registering-the-plugin-class","text":"The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Plugins or ProposalPlugins object, mapped to its subgraph name. The IProposalCreateOptions interface must be included in the already exported ProposalCreateOptions type in the ./src/plugins/utils.ts file. The Init Params interface must also be imported an mapped into the InitParams object in this file. export const ProposalPlugins = { FundingRequest, Join, GenericScheme: GenericPlugin, SchemeRegistrar: PluginRegistrarPlugin, ContributionReward: ContributionRewardPlugin, TokenTrade, Unknown: UnknownPlugin ... } export const Plugins = { ...ProposalPlugins, ReputationFromToken: ReputationFromTokenPlugin, Unknown: UnknownPlugin } export interface IInitParams { GenericScheme: IInitParamsGS, ContributionReward: IInitParamsCR, Competition: IInitParamsCompetition, ... } export type ProposalCreateOptions = IProposalCreateOptionsCRExt | IProposalCreateOptionsGS | IProposalCreateOptionsSR | ...","title":"Registering the Plugin class"},{"location":"tutorials/register-a-plugin/arcjs/#creating-the-proposal-class","text":"The Proposal class definition is, in essence, almost the same as the Plugin class definition, with some differences: The only interface that needs to be declared prior to the class creation is the Proposal State interface, which must always extend the IProposalState interface. An example would be: export interface ITokenTradeProposalState extends IProposalState { dao: IEntityRef<DAO> beneficiary: Address sendTokenAddress: Address sendTokenAmount: number receiveTokenAddress: Address receiveTokenAmount: number executed: boolean redeemed: boolean } The proposal class to be created needs to extend the abstract Proposal class, which takes the interface mentioned above as a type parameter: export class TokenTradeProposal extends Proposal<ITokenTradeProposalState> { ... } The state method must be implemented. It always follows the same implementation. You only need to change the Observable 's type parameter with the proper Proposal State interface: public state(apolloQueryOptions: IApolloQueryOptions): Observable<ITokenTradeProposalState> { const query = gql`query ProposalState { proposal(id: \"${this.id}\") { ...ProposalFields votes { id } stakes { id } } } ${Proposal.baseFragment} ${Plugin.baseFragment} ` const result = this.context.getObservableObject( this.context, query, TokenTradeProposal.itemMap, this.id, apolloQueryOptions ) as Observable<ITokenTradeProposalState> return result } The redeem method must be implemented","title":"Creating the Proposal class"},{"location":"tutorials/register-a-plugin/arcjs/#registering-the-proposal-class","text":"The plugin class must be exported in the ./src/plugins/utils.ts file. Including it in the already exported Proposals object, mapped to its subgraph name: export const Proposals = { GenericScheme: GenericPluginProposal, ContributionReward: ContributionRewardProposal, Competition: CompetitionProposal, ContributionRewardExt: ContributionRewardExtProposal, FundingRequest: FundingRequestProposal, TokenTrade: TokenTradeProposal, Join: JoinProposal, SchemeRegistrar: PluginRegistrarProposal, SchemeRegistrarAdd: PluginRegistrarProposal, SchemeRegistrarRemove: PluginRegistrarProposal, SchemeFactory: PluginManagerProposal, Unknown: UnknownProposal }","title":"Registering the Proposal Class"},{"location":"tutorials/register-a-plugin/arcjs/#exporting-plugin-and-proposal-classes","text":"The folder containing the plugin and proposal classes that were just implemented must be exported in the src/index file: export * from './entity' export * from './plugins/plugin' export * from './plugins/proposal' export * from './plugins/proposalPlugin' export * from './plugins/contributionReward' export * from './plugins/contributionRewardExt' export * from './plugins/tokenTrade' ...","title":"Exporting Plugin and Proposal classes"},{"location":"tutorials/register-a-plugin/arcreact/","text":"","title":"Arcreact"},{"location":"tutorials/register-a-plugin/intro/","text":"","title":"Intro"},{"location":"tutorials/register-a-plugin/migration/","text":"","title":"Migration"},{"location":"tutorials/register-a-plugin/test-environment/","text":"","title":"Test environment"}]}